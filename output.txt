# data_capture_rightmove_service/src/__init__.py


# data_capture_rightmove_service/src/data_capture_rightmove_service/db.py
import asyncio
import time
from typing import AsyncGenerator, Optional

import sqlalchemy.util.concurrency as _concurrency

_concurrency._not_implemented = lambda *args, **kwargs: None

import os
import urllib.parse

from data_capture_rightmove_service.config import settings
from data_capture_rightmove_service.utils.logging_config import logger
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import declarative_base
from sqlalchemy.pool import NullPool
from sqlalchemy.sql import func, text

# --- 1. Centralized Configuration Access ---
DATABASE_URL = settings.DATABASE_URL

# --- 2. Optimized Engine Configuration ---
# All engine and pool settings are consolidated here for clarity.
# These settings are chosen for a balance of performance and resilience,
# especially in a containerized environment like Docker or Kubernetes.
engine: AsyncEngine = create_async_engine(
    DATABASE_URL,
    # Log SQL statements in DEBUG mode only.
    echo=settings.LOGGING_LEVEL.upper() == "DEBUG",
    # --- Connection Pool Settings ---
    pool_size=10,  # The number of connections to keep open in the pool.
    max_overflow=20,  # The number of "extra" connections that can be opened.
    pool_timeout=30,  # Seconds to wait before giving up on getting a connection from the pool.
    pool_recycle=1800,  # Recycle connections every 30 minutes to prevent stale connections.
    # --- CRITICAL OPTIMIZATION ---
    # This is the most important setting for resilience. It runs a simple 'SELECT 1'
    # on a connection before it's checked out from the pool. If the connection is dead,
    # it's discarded and a new one is established. This eliminates most connection errors.
    pool_pre_ping=True,
    # Connection arguments passed directly to the psycopg v3 driver
    connect_args={
        "application_name": "data_capture_rightmove_service",
        # For psycopg v3, we use options parameter instead of server_settings
        "options": "-c timezone=UTC"
        + ("" if settings.ENVIRONMENT == "testing" else " -c statement_timeout=5000"),
    },
)

# --- 3. Standard Session Factory ---
AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    autocommit=False,
    autoflush=False,
    expire_on_commit=False,
)

# --- 4. Declarative Base ---
# All SQLAlchemy models will inherit from this Base.
Base = declarative_base()
Base.metadata.schema = "rightmove"


# --- 5. Simplified and Robust Session Dependency ---
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    FastAPI dependency that provides a transactional, auto-closing database session.

    This standard pattern ensures that:
    1. A new session is created for each request.
    2. The session is always closed, preventing connection leaks.
    3. Any database errors during the request cause a rollback, ensuring data integrity.
    """
    session = AsyncSessionLocal()
    try:
        # Yield the session to the route handler.
        yield session
        # If the route handler finishes without errors, commit the transaction.
        await session.commit()
    except SQLAlchemyError as e:
        # If a database-related error occurs, roll back all changes.
        logger.error(f"Database transaction failed: {e}", exc_info=True)
        await session.rollback()
        # Re-raise the exception to be handled by FastAPI's error handlers.
        raise
    finally:
        # Always close the session to release the connection back to the pool.
        await session.close()


# data_capture_rightmove_service/src/data_capture_rightmove_service/config.py
"""
Configuration module for the Data Capture Rightmove Service.
"""

import os
from enum import Enum
from typing import Any, List, Optional

from pydantic import Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class Environment(str, Enum):
    DEVELOPMENT = "development"
    TESTING = "testing"
    STAGING = "staging"
    PRODUCTION = "production"


class Settings(BaseSettings):
    """
    Settings for the Data Capture Rightmove Service.
    Loads environment variables, with fallbacks to default values where appropriate.
    All environment variables are prefixed with DATA_CAPTURE_RIGHTMOVE_SERVICE_.
    """

    # Core service settings
    ENVIRONMENT: Environment = Field(
        Environment.DEVELOPMENT,
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_ENVIRONMENT",
        description="Application environment",
    )
    ROOT_PATH: str = Field(
        "/api/v1",
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_ROOT_PATH",
        description="API root path for reverse proxies",
    )
    LOGGING_LEVEL: str = Field(
        "INFO",
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_LOGGING_LEVEL",
        description="Logging level",
    )

    # Database configuration
    DATABASE_URL: str = Field(
        ...,
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_DATABASE_URL",
        description="PostgreSQL connection string",
    )

    SUPABASE_URL: str = Field(..., alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_SUPABASE_URL")
    SUPABASE_ANON_KEY: str = Field(
        ..., alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_SUPABASE_ANON_KEY"
    )
    SUPABASE_SERVICE_ROLE_KEY: str = Field(
        ..., alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_SUPABASE_SERVICE_ROLE_KEY"
    )

    # Auth Service connection
    AUTH_SERVICE_URL: str = Field(
        "http://auth-service:8000/api/v1",
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_AUTH_SERVICE_URL",
        description="Auth Service URL for token acquisition",
    )

    # Super ID Service connection
    SUPER_ID_SERVICE_URL: str = Field(
        "http://super-id-service:8000/api/v1",
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_SUPER_ID_SERVICE_URL",
        description="Super ID Service URL for UUID generation",
    )

    # JWT configuration for auth with other services
    M2M_CLIENT_ID: str = Field(
        ...,
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_M2M_CLIENT_ID",
        description="Client ID for machine-to-machine authentication",
    )
    M2M_CLIENT_SECRET: str = Field(
        ...,
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_M2M_CLIENT_SECRET",
        description="Client Secret for machine-to-machine authentication",
    )

    # RapidAPI configuration
    RAPID_API_KEY: str = Field(
        ...,
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_RAPID_API_KEY",
        description="RapidAPI key for accessing Rightmove API",
    )
    RAPID_API_HOST: str = Field(
        "uk-real-estate-rightmove.p.rapidapi.com",
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_RAPID_API_HOST",
        description="RapidAPI host for Rightmove API",
    )

    # Rate limiting
    RATE_LIMIT_REQUESTS_PER_MINUTE: int = Field(
        30,
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_RATE_LIMIT_REQUESTS_PER_MINUTE",
        description="Rate limit for API requests per minute",
    )

    # Redis configuration (for rate limiting and caching)
    REDIS_URL: str = Field(
        "redis://localhost:6379/0",
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_REDIS_URL",
        description="Redis URL for caching and rate limiting",
    )

    # CORS settings
    CORS_ALLOW_ORIGINS: List[str] = Field(
        default_factory=lambda: ["*"],
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_CORS_ALLOW_ORIGINS",
        description="List of origins that are allowed to make cross-origin requests",
    )

    # Rightmove API endpoints
    RIGHTMOVE_API_PROPERTIES_DETAILS_ENDPOINT: str = Field(
        "/properties/details",
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_RIGHTMOVE_API_PROPERTIES_DETAILS_ENDPOINT",
        description="Rightmove API endpoint for property details",
    )
    RIGHTMOVE_API_PROPERTY_FOR_SALE_ENDPOINT: str = Field(
        "/buy/property-for-sale",
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_RIGHTMOVE_API_PROPERTY_FOR_SALE_ENDPOINT",
        description="Rightmove API endpoint for property for sale",
    )

    # Data fetch configuration
    BATCH_SIZE: int = Field(
        10,
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_BATCH_SIZE",
        description="Number of properties to fetch in a batch",
    )
    FETCH_INTERVAL_SECONDS: int = Field(
        3600,
        alias="DATA_CAPTURE_RIGHTMOVE_SERVICE_FETCH_INTERVAL_SECONDS",
        description="Interval between data fetch operations in seconds",
    )

    @field_validator("DATABASE_URL")
    def validate_database_url(cls, v: str, info: Any) -> str:
        # Add any database URL validation logic here if needed
        return v

    def is_production(self) -> bool:
        return self.ENVIRONMENT == Environment.PRODUCTION

    def is_development(self) -> bool:
        return self.ENVIRONMENT == Environment.DEVELOPMENT

    def is_testing(self) -> bool:
        return self.ENVIRONMENT == Environment.TESTING

    model_config = SettingsConfigDict(
        env_file=".env", env_file_encoding="utf-8", case_sensitive=False, extra="ignore"
    )


# Create a global instance of the settings
settings = Settings()


# data_capture_rightmove_service/src/data_capture_rightmove_service/__init__.py


# data_capture_rightmove_service/src/data_capture_rightmove_service/supabase_client.py
import asyncio

from data_capture_rightmove_service.config import settings
from data_capture_rightmove_service.utils.logging_config import logger
from supabase._async.client import AsyncClient as AsyncSupabaseClient
from supabase._async.client import create_client as create_async_supabase_client

# Global instances for both clients
_global_async_supabase_client: AsyncSupabaseClient | None = None
_global_admin_supabase_client: AsyncSupabaseClient | None = None


async def init_supabase_clients():
    """
    Initializes the global Supabase clients.
    This function should be called once at application startup.
    """
    global _global_async_supabase_client, _global_admin_supabase_client

    if _global_async_supabase_client and _global_admin_supabase_client:
        logger.info("Supabase clients already initialized.")
        return

    url = settings.SUPABASE_URL
    anon_key = settings.SUPABASE_ANON_KEY
    service_key = settings.SUPABASE_SERVICE_ROLE_KEY

    if not all([url, anon_key, service_key]):
        logger.error("Supabase URL, Anon Key, or Service Role Key is not configured.")
        raise ValueError("Supabase configuration is incomplete.")

    # --- Initialize Regular Client (with anon key) ---
    logger.info(f"Initializing Supabase AsyncClient with URL: {url[:20]}...")
    try:
        _global_async_supabase_client = await create_async_supabase_client(
            url, anon_key
        )
        logger.info("Supabase AsyncClient initialized successfully.")
    except Exception as e:
        logger.error(f"Failed to initialize Supabase client: {e}", exc_info=True)
        _global_async_supabase_client = None
        raise

    # --- Initialize Admin Client (with service role key) ---
    logger.info("Initializing Supabase Admin Client...")
    try:
        _global_admin_supabase_client = await create_async_supabase_client(
            url, service_key
        )
        logger.info("Supabase Admin Client initialized successfully.")
    except Exception as e:
        logger.error(f"Failed to initialize Supabase Admin client: {e}", exc_info=True)
        _global_admin_supabase_client = None
        raise


async def close_supabase_clients():
    """
    Closes the global Supabase clients by clearing the references.
    This function should be called once at application shutdown.
    """
    global _global_async_supabase_client, _global_admin_supabase_client
    if _global_async_supabase_client or _global_admin_supabase_client:
        logger.info("Closing Supabase clients...")
        _global_async_supabase_client = None
        _global_admin_supabase_client = None
        logger.info("Supabase client references cleared.")


def get_supabase_client() -> AsyncSupabaseClient:
    """
    FastAPI dependency to get the globally initialized anonymous Supabase client.
    """
    if _global_async_supabase_client is None:
        logger.error("Supabase client accessed before initialization.")
        raise RuntimeError("Supabase client not available. Check application lifespan.")
    return _global_async_supabase_client


def get_supabase_admin_client() -> AsyncSupabaseClient:
    """
    FastAPI dependency to get the globally initialized admin (service_role) Supabase client.
    """
    if _global_admin_supabase_client is None:
        logger.error("Supabase admin client accessed before initialization.")
        raise RuntimeError(
            "Supabase admin client not available. Check application lifespan."
        )
    return _global_admin_supabase_client


# data_capture_rightmove_service/src/data_capture_rightmove_service/main.py
"""
Main application entry point for the Data Capture Rightmove Service.
"""

import time
from contextlib import asynccontextmanager

from fastapi import Depends, FastAPI, HTTPException, Request
from fastapi.exceptions import RequestValidationError
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from slowapi import _rate_limit_exceeded_handler
from slowapi.errors import RateLimitExceeded
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from data_capture_rightmove_service.config import settings
from data_capture_rightmove_service.routers.health_router import router as health_router
from data_capture_rightmove_service.routers.property_router import (
    router as property_router,
)
from data_capture_rightmove_service.supabase_client import init_supabase_clients
from data_capture_rightmove_service.utils.logging_config import (
    configure_logging,
    logger,
)
from data_capture_rightmove_service.utils.rate_limiting import limiter
from data_capture_rightmove_service.utils.security import validate_token

# Configure logging using our custom configuration
configure_logging()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Application lifecycle manager with robust initialization and shutdown.

    Handles startup and shutdown sequences with proper error handling.
    """
    logger.info("Application startup sequence initiated.")

    # Initialize app-wide resources and connections
    try:
        await init_supabase_clients()
        logger.info("Supabase clients initialized successfully")
    except Exception as e:
        logger.error(
            f"Failed to initialize Supabase clients: {e.__class__.__name__}: {str(e)}"
        )

    # Initialize startup timestamp for health checks
    app.state.startup_time = time.time()
    logger.info("Application startup complete.")

    # Yield control back to the application
    yield

    # Application Shutdown
    logger.info("Application shutdown sequence initiated.")
    logger.info("Application shutdown complete.")


# Initialize FastAPI app with lifespan
app = FastAPI(
    title="Data Capture Rightmove Service",
    description=(
        "Service for fetching property data from Rightmove via RapidAPI "
        "and storing it in a structured database."
    ),
    version="0.1.0",
    root_path=settings.ROOT_PATH,
    lifespan=lifespan,
)


# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ALLOW_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Add rate limiter middleware
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)


# Include routers
app.include_router(health_router, tags=["Health"])
app.include_router(property_router, tags=["Properties"])


# Add exception handlers
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Custom HTTP exception handler for consistent error responses."""
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail, "error_type": "HTTPException"},
    )


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Validation exception handler for consistent error responses."""
    return JSONResponse(
        status_code=422,
        content={"detail": str(exc), "error_type": "ValidationError"},
    )


@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """Global exception handler for consistent error responses."""
    logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "detail": "Internal server error",
            "error_type": str(type(exc).__name__),
        },
    )


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "data_capture_rightmove_service.main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.is_development(),
        log_level=settings.LOGGING_LEVEL.lower(),
    )


# data_capture_rightmove_service/src/data_capture_rightmove_service/routers/__init__.py
"""
API routers for the Data Capture Rightmove Service.
"""

from data_capture_rightmove_service.routers.health_router import router as health_router
from data_capture_rightmove_service.routers.property_router import router as property_router

__all__ = ['health_router', 'property_router']


# data_capture_rightmove_service/src/data_capture_rightmove_service/routers/property_router.py
"""
Router for property data operations, including fetching from Rightmove API and storing in database.
"""

import asyncio
import uuid
from typing import Dict, List, Optional

from fastapi import (
    APIRouter,
    BackgroundTasks,
    Depends,
    HTTPException,
    Query,
    Request,
    Security,
)
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from data_capture_rightmove_service.clients.rightmove_api_client import (
    rightmove_api_client,
)
from data_capture_rightmove_service.clients.super_id_service_client import (
    super_id_service_client,
)
from data_capture_rightmove_service.crud.properties_details import (
    get_all_property_ids,
    get_property_details_by_id,
    store_properties_details,
)
from data_capture_rightmove_service.crud.property_details import (
    get_all_property_sale_ids,
    get_property_sale_details_by_id,
    store_property_details,
)
from data_capture_rightmove_service.db import get_db
from data_capture_rightmove_service.schemas.common import MessageResponse
from data_capture_rightmove_service.schemas.property_data import (
    FetchBatchRequest,
    FetchBatchResponse,
    FetchPropertyDetailsRequest,
    FetchPropertyResponse,
    PropertyDetailsStorageResponse,
    PropertySearchRequest,
)
from data_capture_rightmove_service.utils.logging_config import logger
from data_capture_rightmove_service.utils.security import requires_scope, validate_token
from data_capture_rightmove_service.utils.url_parsing import (
    extract_rightmove_property_id,
    is_valid_rightmove_url,
)

router = APIRouter(prefix="/properties", tags=["Properties"])


class PropertyUrlResponse(BaseModel):
    """Response for property URL validation and extraction"""

    url: str = Field(..., description="The URL that was checked")
    valid: bool = Field(..., description="Whether the URL is valid")
    property_id: Optional[int] = Field(
        None, description="Extracted property ID if valid"
    )
    message: str = Field(..., description="Message describing the result")


class CombinedPropertyResponseItem(BaseModel):
    """Response item for a single API call in the combined fetch endpoint"""

    api_endpoint: str = Field(..., description="The API endpoint that was called")
    property_id: int = Field(..., description="The property ID")
    super_id: uuid.UUID = Field(..., description="Super ID for tracking purposes")
    stored: bool = Field(..., description="Whether the data was stored successfully")
    message: str = Field(..., description="Success or error message")


class CombinedPropertyResponse(BaseModel):
    """Response for the combined fetch endpoint"""

    property_id: int = Field(..., description="The property ID")
    property_url: Optional[str] = Field(
        None, description="The property URL if provided"
    )
    results: List[CombinedPropertyResponseItem] = Field(
        ..., description="Results from each API call"
    )


@router.post("/fetch/combined", response_model=CombinedPropertyResponse)
async def fetch_combined_property_data(
    request: FetchPropertyDetailsRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
) -> CombinedPropertyResponse:
    """
    Fetch property data from BOTH Rightmove API endpoints (properties/details and property-for-sale)
    and store ALL data in the database.

    Either property_id or property_url must be provided.
    If property_url is provided, the property_id will be extracted from it.

    This endpoint handles both API calls in a single request and ensures all data is stored.
    """
    try:
        # Extract property ID if URL is provided
        property_id = request.property_id
        property_url = request.property_url

        if not property_id and property_url:
            property_id = extract_rightmove_property_id(property_url)
            if not property_id:
                raise HTTPException(
                    status_code=400,
                    detail=f"Failed to extract property ID from URL: {property_url}",
                )
        elif not property_id:
            raise HTTPException(
                status_code=400,
                detail="Either property_id or property_url must be provided",
            )

        # Results container
        results = []

        # 1. Fetch and store properties/details data
        try:
            # Use provided super_id or create a new one for properties/details
            super_id_details = request.super_id
            if not super_id_details:
                description = (
                    request.description
                    or f"Rightmove properties/details fetch for property ID: {property_id}"
                )
                super_id_details = await super_id_service_client.create_super_id(
                    description=description
                )

            # Fetch from Rightmove API - properties/details endpoint
            property_details_data = await rightmove_api_client.get_property_details(
                str(property_id)
            )

            if property_details_data:
                # Store in database - ensure ALL data is stored
                success, message = await store_properties_details(
                    db, property_details_data, super_id_details
                )

                # Add to results
                results.append(
                    CombinedPropertyResponseItem(
                        api_endpoint="properties/details",
                        property_id=property_id,
                        super_id=super_id_details,
                        stored=success,
                        message=message,
                    )
                )
            else:
                results.append(
                    CombinedPropertyResponseItem(
                        api_endpoint="properties/details",
                        property_id=property_id,
                        super_id=super_id_details,
                        stored=False,
                        message=f"No data returned from properties/details endpoint for ID: {property_id}",
                    )
                )
        except Exception as e:
            logger.error(f"Error in properties/details fetch: {str(e)}")
            if super_id_details:
                results.append(
                    CombinedPropertyResponseItem(
                        api_endpoint="properties/details",
                        property_id=property_id,
                        super_id=super_id_details,
                        stored=False,
                        message=f"Error: {str(e)}",
                    )
                )

        # 2. Fetch and store property-for-sale/detail data
        try:
            # Always create a new super_id for the second API call to ensure proper tracking
            description = (
                request.description
                or f"Rightmove property-for-sale fetch for property ID: {property_id}"
            )
            super_id_sale = await super_id_service_client.create_super_id(
                description=description
            )

            # Fetch from Rightmove API - property-for-sale endpoint
            property_sale_data = (
                await rightmove_api_client.get_property_for_sale_details(
                    str(property_id)
                )
            )

            if property_sale_data:
                # Store in database - ensure ALL data is stored
                success, message = await store_property_details(
                    db, property_sale_data, super_id_sale
                )

                # Add to results
                results.append(
                    CombinedPropertyResponseItem(
                        api_endpoint="property-for-sale/detail",
                        property_id=property_id,
                        super_id=super_id_sale,
                        stored=success,
                        message=message,
                    )
                )
            else:
                results.append(
                    CombinedPropertyResponseItem(
                        api_endpoint="property-for-sale/detail",
                        property_id=property_id,
                        super_id=super_id_sale,
                        stored=False,
                        message=f"No data returned from property-for-sale endpoint for ID: {property_id}",
                    )
                )
        except Exception as e:
            logger.error(f"Error in property-for-sale fetch: {str(e)}")
            if "super_id_sale" in locals():
                results.append(
                    CombinedPropertyResponseItem(
                        api_endpoint="property-for-sale/detail",
                        property_id=property_id,
                        super_id=super_id_sale,
                        stored=False,
                        message=f"Error: {str(e)}",
                    )
                )

        # Return combined results
        return CombinedPropertyResponse(
            property_id=property_id, property_url=property_url, results=results
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in combined property fetch: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to fetch and store combined property data: {str(e)}",
        )


@router.get("/validate-url", response_model=PropertyUrlResponse)
async def validate_property_url(
    url: str = Query(..., description="Rightmove property URL to validate")
):
    """
    Validate a Rightmove property URL and extract the property ID.

    This endpoint is useful for client applications to check if a URL is valid
    and to extract the property ID before submitting the URL for processing.
    """
    try:
        # Check if URL is valid
        if not is_valid_rightmove_url(url):
            return PropertyUrlResponse(
                url=url,
                valid=False,
                property_id=None,
                message="Invalid Rightmove property URL",
            )

        # Extract property ID
        property_id = extract_rightmove_property_id(url)
        if not property_id:
            return PropertyUrlResponse(
                url=url,
                valid=False,
                property_id=None,
                message="Could not extract property ID from URL",
            )

        return PropertyUrlResponse(
            url=url,
            valid=True,
            property_id=property_id,
            message=f"Successfully extracted property ID: {property_id}",
        )
    except Exception as e:
        logger.error(f"Error validating property URL: {str(e)}")
        return PropertyUrlResponse(
            url=url,
            valid=False,
            property_id=None,
            message=f"Error processing URL: {str(e)}",
        )


@router.post("/fetch/details", response_model=PropertyDetailsStorageResponse)
async def fetch_property_details(
    request: FetchPropertyDetailsRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
) -> PropertyDetailsStorageResponse:
    """
    Fetch property details from Rightmove API and store in database.
    Uses the properties/details endpoint.

    Either property_id or property_url must be provided.
    If property_url is provided, the property_id will be extracted from it.
    """
    try:
        # Extract property ID if URL is provided
        property_id = request.property_id
        if not property_id and request.property_url:
            property_id = extract_rightmove_property_id(request.property_url)
            if not property_id:
                raise HTTPException(
                    status_code=400,
                    detail=f"Failed to extract property ID from URL: {request.property_url}",
                )
        elif not property_id:
            raise HTTPException(
                status_code=400,
                detail="Either property_id or property_url must be provided",
            )

        # Use provided super_id or create a new one
        super_id = request.super_id
        if not super_id:
            description = (
                request.description
                or f"Rightmove property details fetch for property ID: {property_id}"
            )
            super_id = await super_id_service_client.create_super_id(
                description=description
            )

        # Fetch from Rightmove API
        property_data = await rightmove_api_client.get_property_details(
            str(property_id)
        )

        if not property_data:
            raise HTTPException(
                status_code=404,
                detail=f"Property details not found for ID: {property_id}",
            )

        # Store in database
        success, message = await store_properties_details(db, property_data, super_id)

        return PropertyDetailsStorageResponse(
            property_id=property_id,
            super_id=super_id,
            stored=success,
            message=message,
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching property details: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to fetch and store property details: {str(e)}",
        )


@router.post("/fetch/property-for-sale", response_model=PropertyDetailsStorageResponse)
async def fetch_property_for_sale_details(
    request: FetchPropertyDetailsRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
) -> PropertyDetailsStorageResponse:
    """
    Fetch property for sale details from Rightmove API and store in database.
    Uses the property-for-sale/detail endpoint.

    Either property_id or property_url must be provided.
    If property_url is provided, the property_id will be extracted from it.
    """
    try:
        # Extract property ID if URL is provided
        property_id = request.property_id
        if not property_id and request.property_url:
            property_id = extract_rightmove_property_id(request.property_url)
            if not property_id:
                raise HTTPException(
                    status_code=400,
                    detail=f"Failed to extract property ID from URL: {request.property_url}",
                )
        elif not property_id:
            raise HTTPException(
                status_code=400,
                detail="Either property_id or property_url must be provided",
            )

        # Use provided super_id or create a new one
        super_id = request.super_id
        if not super_id:
            description = (
                request.description
                or f"Rightmove property for sale fetch for property ID: {property_id}"
            )
            super_id = await super_id_service_client.create_super_id(
                description=description
            )

        # Fetch from Rightmove API
        property_data = await rightmove_api_client.get_property_for_sale_details(
            str(property_id)
        )

        if not property_data:
            raise HTTPException(
                status_code=404,
                detail=f"Property for sale details not found for ID: {property_id}",
            )

        # Store in database
        success, message = await store_property_details(db, property_data, super_id)

        return PropertyDetailsStorageResponse(
            property_id=property_id,
            super_id=super_id,
            stored=success,
            message=message,
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching property for sale details: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to fetch and store property for sale details: {str(e)}",
        )


@router.post("/fetch/batch", response_model=FetchBatchResponse)
async def fetch_batch_properties(
    request: FetchBatchRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
) -> FetchBatchResponse:
    """
    Fetch multiple properties in a batch operation.
    This endpoint processes property IDs in parallel for faster batch processing.
    """
    if not request.property_ids:
        raise HTTPException(status_code=400, detail="No property IDs provided")

    if len(request.property_ids) > 50:
        raise HTTPException(
            status_code=400, detail="Maximum batch size is 50 properties"
        )

    # Get a batch ID (super_id) for tracking this batch operation
    batch_id = await super_id_service_client.create_super_id(
        description=f"Rightmove batch property fetch ({request.api_type}) for {len(request.property_ids)} properties"
    )

    # Define the processing function based on API type
    if request.api_type == "properties_details":
        process_func = process_property_details
    elif request.api_type == "property_for_sale":
        process_func = process_property_for_sale
    else:
        raise HTTPException(status_code=400, detail="Invalid API type specified")

    # Process properties in parallel
    tasks = []
    for property_id in request.property_ids:
        tasks.append(process_func(property_id, db))

    # Wait for all tasks to complete
    results = await asyncio.gather(*tasks, return_exceptions=True)

    # Process results
    successful = 0
    failed = 0
    property_results = []

    for result in results:
        if isinstance(result, Exception):
            # Handle exception case
            failed += 1
            logger.error(f"Error in batch processing: {str(result)}")
            property_results.append(
                FetchPropertyResponse(
                    property_id=0,  # Unknown property ID
                    super_id=uuid.UUID(int=0),  # Placeholder UUID
                    status="failed",
                    message=f"Error: {str(result)}",
                )
            )
        else:
            # Handle successful case
            property_id, super_id, status, message = result
            if status == "success":
                successful += 1
            else:
                failed += 1

            property_results.append(
                FetchPropertyResponse(
                    property_id=property_id,
                    super_id=super_id,
                    status=status,
                    message=message,
                )
            )

    return FetchBatchResponse(
        batch_id=batch_id,
        total=len(request.property_ids),
        successful=successful,
        failed=failed,
        results=property_results,
    )


async def process_property_details(property_id: int, db: AsyncSession) -> tuple:
    """Process a single property using the properties/details endpoint."""
    try:
        # Get a super_id for tracking this request
        super_id = await super_id_service_client.create_super_id(
            description=f"Rightmove property details fetch for property ID: {property_id}"
        )

        # Fetch from Rightmove API
        property_data = await rightmove_api_client.get_property_details(
            str(property_id)
        )

        if not property_data:
            return (
                property_id,
                super_id,
                "failed",
                f"Property details not found for ID: {property_id}",
            )

        # Store in database
        success, message = await store_properties_details(db, property_data, super_id)

        status = "success" if success else "failed"
        return property_id, super_id, status, message

    except Exception as e:
        logger.error(
            f"Error processing property details for ID {property_id}: {str(e)}"
        )
        return property_id, uuid.UUID(int=0), "failed", f"Error: {str(e)}"


async def process_property_for_sale(property_id: int, db: AsyncSession) -> tuple:
    """Process a single property using the property-for-sale/detail endpoint."""
    try:
        # Get a super_id for tracking this request
        super_id = await super_id_service_client.create_super_id(
            description=f"Rightmove property for sale fetch for property ID: {property_id}"
        )

        # Fetch from Rightmove API
        property_data = await rightmove_api_client.get_property_for_sale_details(
            str(property_id)
        )

        if not property_data:
            return (
                property_id,
                super_id,
                "failed",
                f"Property for sale details not found for ID: {property_id}",
            )

        # Store in database
        success, message = await store_property_details(db, property_data, super_id)

        status = "success" if success else "failed"
        return property_id, super_id, status, message

    except Exception as e:
        logger.error(
            f"Error processing property for sale for ID {property_id}: {str(e)}"
        )
        return property_id, uuid.UUID(int=0), "failed", f"Error: {str(e)}"


@router.get("/details/{property_id}", response_model=Dict)
async def get_property_details(
    property_id: int, db: AsyncSession = Depends(get_db)
) -> Dict:
    """
    Get property details from the database by ID.
    Uses data from the properties/details endpoint.
    """
    property_data = await get_property_details_by_id(db, property_id)
    if not property_data:
        raise HTTPException(
            status_code=404, detail=f"Property details not found for ID: {property_id}"
        )
    return property_data


@router.get("/property-for-sale/{property_id}", response_model=Dict)
async def get_property_for_sale(
    property_id: int, db: AsyncSession = Depends(get_db)
) -> Dict:
    """
    Get property for sale details from the database by ID.
    Uses data from the property-for-sale/detail endpoint.
    """
    property_data = await get_property_sale_details_by_id(db, property_id)
    if not property_data:
        raise HTTPException(
            status_code=404,
            detail=f"Property for sale details not found for ID: {property_id}",
        )
    return property_data


@router.post("/search", response_model=Dict)
async def search_properties(
    search_request: PropertySearchRequest,
    background_tasks: BackgroundTasks,
    store_results: bool = Query(
        False, description="Whether to store search results in the database"
    ),
) -> Dict:
    """
    Search for properties using the Rightmove API.
    Optionally store the results in the database if store_results is True.
    """
    try:
        # Call the Rightmove API search endpoint
        search_results = await rightmove_api_client.search_properties_for_sale(
            location=search_request.location,
            min_price=search_request.min_price,
            max_price=search_request.max_price,
            min_bedrooms=search_request.min_bedrooms,
            max_bedrooms=search_request.max_bedrooms,
            property_type=search_request.property_type,
            radius=search_request.radius,
            page_number=search_request.page_number,
            page_size=search_request.page_size,
        )

        # If store_results is True, store each property in the database
        if store_results and "properties" in search_results:
            # This should be done as a background task to not block the response
            background_tasks.add_task(
                store_search_results, search_results.get("properties", [])
            )

        return search_results

    except Exception as e:
        logger.error(f"Error searching properties: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to search properties: {str(e)}"
        )


async def store_search_results(properties: List[Dict]) -> None:
    """Store search results in the database as a background task."""
    async with AsyncSession(bind=db_engine) as db:
        for property_data in properties:
            try:
                # Get property ID from the data
                property_id = property_data.get("id")
                if not property_id:
                    logger.warning("Property data missing ID, skipping")
                    continue

                # Get a super_id for tracking this property
                super_id = await super_id_service_client.create_super_id(
                    description=f"Rightmove search result for property ID: {property_id}"
                )

                # Store in database - pick the right function based on available data
                if "propertySubType" in property_data:
                    # This looks like the property-for-sale format
                    await store_property_details(db, property_data, super_id)
                else:
                    # Try the properties/details format
                    await store_properties_details(db, property_data, super_id)

            except Exception as e:
                logger.error(f"Error storing search result: {str(e)}")
                # Continue with next property, don't fail the entire batch


@router.get("/ids", response_model=List[int])
async def list_property_ids(
    limit: int = Query(100, le=1000),
    offset: int = Query(0, ge=0),
    api_type: str = Query(
        "properties_details",
        description="API type: 'properties_details' or 'property_for_sale'",
    ),
    db: AsyncSession = Depends(get_db),
) -> List[int]:
    """
    List property IDs stored in the database.
    Supports pagination with limit and offset parameters.
    """
    if api_type == "properties_details":
        return await get_all_property_ids(db, limit, offset)
    elif api_type == "property_for_sale":
        return await get_all_property_sale_ids(db, limit, offset)
    else:
        raise HTTPException(status_code=400, detail="Invalid API type specified")


# data_capture_rightmove_service/src/data_capture_rightmove_service/routers/health_router.py
"""
Health check endpoints for monitoring service status.
"""

import os
import time
from datetime import datetime

from fastapi import APIRouter, Depends, Request, Security
from fastapi.security import HTTPBearer
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession
from supabase._async.client import AsyncClient as AsyncSupabaseClient

from data_capture_rightmove_service.clients.auth_service_client import (
    auth_service_client,
)
from data_capture_rightmove_service.clients.super_id_service_client import (
    super_id_service_client,
)
from data_capture_rightmove_service.config import settings
from data_capture_rightmove_service.db import get_db
from data_capture_rightmove_service.schemas.common import (
    ComponentHealth,
    HealthCheckResponse,
    HealthStatus,
)
from data_capture_rightmove_service.utils.logging_config import logger
from data_capture_rightmove_service.utils.security import validate_token

router = APIRouter(tags=["Health"])

# Track app startup time for uptime monitoring
start_time = time.time()


@router.get("/health", response_model=HealthCheckResponse)
async def health_check(
    request: Request,
    db: AsyncSession = Depends(get_db),
) -> HealthCheckResponse:
    """
    Basic health check endpoint for the service.
    Can be used by Kubernetes liveness and readiness probes.
    """
    current_time = datetime.utcnow()
    response = {
        "status": HealthStatus.OK,
        "version": "0.1.0",  # TODO: Get from version file
        "timestamp": current_time,
        "components": {"api": {"status": HealthStatus.OK}},
        "uptime_seconds": time.time() - start_time,
    }

    # Check database connectivity
    try:
        result = await db.execute(text("SELECT 1"))
        row = result.scalar()
        if row == 1:
            response["components"]["database"] = {"status": HealthStatus.OK}
        else:
            response["components"]["database"] = {
                "status": HealthStatus.ERROR,
                "message": "Database query returned unexpected result",
            }
            response["status"] = HealthStatus.ERROR
    except Exception as e:
        logger.error(f"Database health check failed: {str(e)}")
        response["components"]["database"] = {
            "status": HealthStatus.ERROR,
            "message": f"Database connection error: {str(e)}",
        }
        response["status"] = HealthStatus.ERROR

    # For Kubernetes probes, we might want to simplify the response
    is_k8s_probe = "kube-probe" in request.headers.get("user-agent", "").lower()

    # If this is a Kubernetes probe and we want to avoid pod restarts during maintenance,
    # we could always return status OK, but log the actual status
    if is_k8s_probe and response["status"] != HealthStatus.OK:
        logger.warning(
            f"Health check failed but reporting OK for K8s probe: {response}"
        )
        # For K8s probes, we still report OK to avoid unnecessary pod restarts
        response["status"] = HealthStatus.OK

    return HealthCheckResponse(**response)


@router.get("/health/detailed", response_model=HealthCheckResponse)
async def detailed_health_check(
    request: Request,
    db: AsyncSession = Depends(get_db),
) -> HealthCheckResponse:
    """
    Detailed health check that tests connectivity to all dependent services.
    This is more thorough than the basic health check and intended for internal monitoring.
    """
    # Start with basic health check
    response = await health_check(request, db)
    response_dict = response.model_dump()

    # Check auth service connectivity
    try:
        # Log the attempt to access auth service
        logger.debug(
            f"Testing auth service connectivity at: {settings.AUTH_SERVICE_URL}"
        )
        # Just test if we can get a token
        token = await auth_service_client.get_token()
        if token:
            response_dict["components"]["auth_service"] = {"status": HealthStatus.OK}
        else:
            response_dict["components"]["auth_service"] = {
                "status": HealthStatus.ERROR,
                "message": "Failed to acquire token from auth service",
            }
            response_dict["status"] = HealthStatus.ERROR
    except Exception as e:
        logger.error(f"Auth service health check failed: {str(e)}")
        response_dict["components"]["auth_service"] = {
            "status": HealthStatus.ERROR,
            "message": f"Auth service error: {str(e)}",
        }
        response_dict["status"] = HealthStatus.ERROR

    # Check super ID service connectivity (only if auth service is OK)
    if (
        response_dict["components"].get("auth_service", {}).get("status")
        == HealthStatus.OK
    ):
        try:
            # Log the attempt to access super_id service
            logger.debug(
                f"Testing super_id service connectivity at: {settings.SUPER_ID_SERVICE_URL}"
            )
            # Create a test super ID
            super_id = await super_id_service_client.create_super_id(
                description="Health check test"
            )
            if super_id:
                response_dict["components"]["super_id_service"] = {
                    "status": HealthStatus.OK
                }
            else:
                response_dict["components"]["super_id_service"] = {
                    "status": HealthStatus.ERROR,
                    "message": "Failed to generate super ID",
                }
                response_dict["status"] = HealthStatus.ERROR
        except Exception as e:
            logger.error(f"Super ID service health check failed: {str(e)}")
            response_dict["components"]["super_id_service"] = {
                "status": HealthStatus.ERROR,
                "message": f"Super ID service error: {str(e)}",
            }
            response_dict["status"] = HealthStatus.ERROR

    # Include environment information
    response_dict["components"]["environment"] = {
        "status": HealthStatus.OK,
        "message": f"Environment: {settings.ENVIRONMENT}",
    }

    # Include process information
    response_dict["components"]["process"] = {
        "status": HealthStatus.OK,
        "message": f"PID: {os.getpid()}",
    }

    return HealthCheckResponse(**response_dict)


# data_capture_rightmove_service/src/data_capture_rightmove_service/clients/rightmove_api_client.py
"""
Rightmove API Client for fetching property data from RapidAPI.
"""

import logging
from typing import Any, Dict, List, Optional

import httpx
from fastapi import HTTPException

from data_capture_rightmove_service.config import settings

logger = logging.getLogger(__name__)


class RightmoveApiClient:
    """
    Client for fetching property data from the Rightmove API via RapidAPI.
    Handles rate limiting, error handling, and response parsing.
    """

    def __init__(self, api_key: str = None, api_host: str = None):
        """
        Initialize the Rightmove API Client.

        Args:
            api_key: RapidAPI key, defaults to the value in settings
            api_host: RapidAPI host, defaults to the value in settings
        """
        self.api_key = api_key or settings.RAPID_API_KEY
        self.api_host = api_host or settings.RAPID_API_HOST
        self.base_url = f"https://{self.api_host}"

        # Default headers for all requests
        self._default_headers = {
            "X-RapidAPI-Key": self.api_key,
            "X-RapidAPI-Host": self.api_host,
        }

    async def _make_request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        max_retries: int = 1,
    ) -> Dict[str, Any]:
        """
        Make a request to the Rightmove API with appropriate headers and error handling.

        Args:
            method: HTTP method to use (GET, POST, etc.)
            endpoint: API endpoint to call
            params: Query parameters to include
            max_retries: Maximum number of retries on rate limit errors

        Returns:
            Dict[str, Any]: API response data

        Raises:
            HTTPException: If the API request fails
        """
        url = f"{self.base_url}{endpoint}"
        retries = 0

        while retries <= max_retries:
            try:
                async with httpx.AsyncClient() as client:
                    if method.upper() == "GET":
                        response = await client.get(
                            url,
                            params=params,
                            headers=self._default_headers,
                            timeout=30.0,  # Longer timeout for property data
                        )
                    elif method.upper() == "POST":
                        response = await client.post(
                            url,
                            json=params,
                            headers=self._default_headers,
                            timeout=30.0,
                        )
                    else:
                        raise ValueError(f"Unsupported HTTP method: {method}")

                    # Handle rate limiting
                    if response.status_code == 429:
                        retries += 1
                        if retries > max_retries:
                            logger.error("Rate limit exceeded and max retries reached")
                            raise HTTPException(
                                status_code=429,
                                detail="Rate limit exceeded from RapidAPI Rightmove API",
                            )
                        logger.warning(
                            f"Rate limit hit, retrying {retries}/{max_retries}..."
                        )
                        await asyncio.sleep(1)  # Wait before retrying
                        continue

                    # Handle other errors
                    response.raise_for_status()
                    
                    # Parse the response JSON
                    response_data = response.json()
                    
                    # Log the response structure for debugging
                    logger.debug(f"API Response URL: {url}")
                    logger.debug(f"API Response Status: {response.status_code}")
                    logger.debug(f"API Response Structure - Top-level keys: {list(response_data.keys())}")
                    
                    # Log nested data structure if present
                    if "data" in response_data and isinstance(response_data["data"], dict):
                        logger.debug(f"API Response Nested data keys: {list(response_data['data'].keys())}")
                        
                        # Look for ID fields in the nested data
                        id_fields = ["id", "propertyId", "property_id"]
                        for field in id_fields:
                            if field in response_data["data"]:
                                logger.debug(f"Found ID field '{field}' in data: {response_data['data'][field]}")
                    
                    return response_data

            except httpx.HTTPError as e:
                logger.error(f"HTTP error when calling Rightmove API: {str(e)}")
                if hasattr(e, "response") and e.response is not None:
                    status_code = e.response.status_code
                    try:
                        error_detail = e.response.json()
                        detail = f"Rightmove API error: {error_detail}"
                    except Exception:
                        detail = f"Rightmove API error: {str(e)}"
                else:
                    status_code = 503
                    detail = f"Rightmove API service unavailable: {str(e)}"

                raise HTTPException(status_code=status_code, detail=detail)

            except Exception as e:
                logger.error(f"Unexpected error when calling Rightmove API: {str(e)}")
                raise HTTPException(
                    status_code=500,
                    detail=f"Unexpected error when calling Rightmove API: {str(e)}",
                )

    async def get_property_details(self, property_id: str) -> Dict[str, Any]:
        """
        Get detailed information about a specific property using the properties/details endpoint.

        Args:
            property_id: The Rightmove property ID

        Returns:
            Dict[str, Any]: Property details

        Raises:
            HTTPException: If the API request fails
        """
        endpoint = settings.RIGHTMOVE_API_PROPERTIES_DETAILS_ENDPOINT
        params = {"identifier": property_id}  # Use 'identifier' parameter instead of 'propertyId'

        logger.info(f"Fetching property details for ID: {property_id}")
        return await self._make_request("GET", endpoint, params, max_retries=2)

    async def get_property_for_sale_details(self, property_id: str) -> Dict[str, Any]:
        """
        Get detailed information about a property for sale using the correct endpoint.

        Args:
            property_id: The Rightmove property ID

        Returns:
            Dict[str, Any]: Property details

        Raises:
            HTTPException: If the API request fails
        """
        # The correct endpoint format is /buy/property-for-sale/detail with 'id' parameter
        endpoint = f"/buy{settings.RIGHTMOVE_API_PROPERTY_FOR_SALE_ENDPOINT}/detail"
        params = {"id": property_id}  # Use 'id' parameter instead of 'propertyId'

        logger.info(f"Fetching property-for-sale details for ID: {property_id} using endpoint {endpoint}")
        return await self._make_request("GET", endpoint, params, max_retries=2)

    async def search_properties_for_sale(
        self,
        location: str,
        min_price: Optional[int] = None,
        max_price: Optional[int] = None,
        min_bedrooms: Optional[int] = None,
        max_bedrooms: Optional[int] = None,
        property_type: Optional[str] = None,
        radius: Optional[float] = None,
        page_number: int = 0,
        page_size: int = 10,
    ) -> Dict[str, Any]:
        """
        Search for properties for sale based on criteria.

        Args:
            location: Location to search in (e.g., "London")
            min_price: Minimum price
            max_price: Maximum price
            min_bedrooms: Minimum number of bedrooms
            max_bedrooms: Maximum number of bedrooms
            property_type: Type of property (e.g., "FLAT", "HOUSE")
            radius: Search radius in miles
            page_number: Page number for pagination
            page_size: Number of results per page

        Returns:
            Dict[str, Any]: Search results

        Raises:
            HTTPException: If the API request fails
        """
        endpoint = f"{settings.RIGHTMOVE_API_PROPERTY_FOR_SALE_ENDPOINT}"

        # Build query parameters
        params = {
            "locationIdentifier": location,
            "index": page_number,
            "sortType": 6,
            "numberOfPropertiesPerPage": page_size,
        }

        if min_price is not None:
            params["minPrice"] = min_price

        if max_price is not None:
            params["maxPrice"] = max_price

        if min_bedrooms is not None:
            params["minBedrooms"] = min_bedrooms

        if max_bedrooms is not None:
            params["maxBedrooms"] = max_bedrooms

        if property_type is not None:
            params["propertyType"] = property_type

        if radius is not None:
            params["radius"] = radius

        logger.info(f"Searching properties for sale with criteria: {params}")
        return await self._make_request("GET", endpoint, params, max_retries=2)


# Create a global instance of the Rightmove API client
rightmove_api_client = RightmoveApiClient()


# data_capture_rightmove_service/src/data_capture_rightmove_service/clients/__init__.py
"""
Client modules for external service integrations.
"""

from data_capture_rightmove_service.clients.auth_service_client import auth_service_client
from data_capture_rightmove_service.clients.super_id_service_client import super_id_service_client
from data_capture_rightmove_service.clients.rightmove_api_client import rightmove_api_client

__all__ = ['auth_service_client', 'super_id_service_client', 'rightmove_api_client']


# data_capture_rightmove_service/src/data_capture_rightmove_service/clients/super_id_service_client.py
"""
Super ID Service Client for generating and retrieving tracking UUIDs.
"""

import logging
import uuid
from typing import Dict, Optional

import httpx
from fastapi import HTTPException

from data_capture_rightmove_service.clients.auth_service_client import (
    auth_service_client,
)
from data_capture_rightmove_service.config import settings

logger = logging.getLogger(__name__)


class SuperIdServiceClient:
    """
    Client for interacting with the Super ID Service API for UUID generation and tracking.
    """

    def __init__(self, base_url: str = None):
        """
        Initialize the Super ID Service Client.

        Args:
            base_url: Base URL for the Super ID Service API, defaults to the value in settings
        """
        self.base_url = base_url or settings.SUPER_ID_SERVICE_URL

    async def create_super_id(
        self,
        source_service: str = "data_capture_rightmove_service",
        description: str = None,
    ) -> uuid.UUID:
        """
        Generate a new Super ID UUID for tracking purposes.

        Args:
            source_service: The name of the service requesting the Super ID
            description: Optional description of what this Super ID is for

        Returns:
            uuid.UUID: The generated UUID

        Raises:
            HTTPException: If Super ID generation fails
        """
        try:
            # Get auth headers with a valid token
            headers = await auth_service_client.get_auth_header()

            payload = {
                "source_service": source_service,
                "description": description or "Rightmove data capture request",
            }

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/super_ids",
                    json=payload,
                    headers=headers,
                    timeout=10.0,
                )

                response.raise_for_status()
                data = response.json()

                # Return the UUID from the response
                return uuid.UUID(data["super_id"])

        except httpx.HTTPError as e:
            logger.error(f"Failed to generate Super ID: {str(e)}")
            if isinstance(e, httpx.HTTPStatusError) and e.response.status_code == 401:
                # If unauthorized, try with a fresh token
                try:
                    headers = await auth_service_client.get_auth_header(
                        force_refresh=True
                    )
                    async with httpx.AsyncClient() as client:
                        response = await client.post(
                            f"{self.base_url}/super_ids",
                            json=payload,
                            headers=headers,
                            timeout=10.0,
                        )

                        response.raise_for_status()
                        data = response.json()

                        return uuid.UUID(data["super_id"])
                except httpx.HTTPError as retry_err:
                    logger.error(
                        f"Failed to generate Super ID after token refresh: {str(retry_err)}"
                    )
                    raise HTTPException(
                        status_code=503,
                        detail=f"Super ID service unavailable: {str(retry_err)}",
                    )
            raise HTTPException(
                status_code=503,
                detail=f"Super ID service unavailable: {str(e)}",
            )

    async def get_super_id_info(self, super_id: uuid.UUID) -> Dict:
        """
        Get information about an existing Super ID.

        Args:
            super_id: The UUID to look up

        Returns:
            Dict: Information about the Super ID

        Raises:
            HTTPException: If Super ID lookup fails
        """
        try:
            # Get auth headers with a valid token
            headers = await auth_service_client.get_auth_header()

            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/super_ids/{super_id}",
                    headers=headers,
                    timeout=10.0,
                )

                response.raise_for_status()
                return response.json()

        except httpx.HTTPError as e:
            logger.error(f"Failed to get Super ID info: {str(e)}")
            if isinstance(e, httpx.HTTPStatusError) and e.response.status_code == 401:
                # If unauthorized, try with a fresh token
                try:
                    headers = await auth_service_client.get_auth_header(
                        force_refresh=True
                    )
                    async with httpx.AsyncClient() as client:
                        response = await client.get(
                            f"{self.base_url}/super_ids/{super_id}",
                            headers=headers,
                            timeout=10.0,
                        )

                        response.raise_for_status()
                        return response.json()
                except httpx.HTTPError as retry_err:
                    logger.error(
                        f"Failed to get Super ID info after token refresh: {str(retry_err)}"
                    )
                    raise HTTPException(
                        status_code=503,
                        detail=f"Super ID service unavailable: {str(retry_err)}",
                    )
            raise HTTPException(
                status_code=503,
                detail=f"Super ID service unavailable: {str(e)}",
            )


# Create a global instance of the super ID service client
super_id_service_client = SuperIdServiceClient()


# data_capture_rightmove_service/src/data_capture_rightmove_service/clients/auth_service_client.py
"""
Auth Service Client for acquiring M2M tokens to authenticate with other services.
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, Optional

import httpx

from data_capture_rightmove_service.config import settings

logger = logging.getLogger(__name__)


class AuthServiceClient:
    """
    Client for interacting with the Auth Service API for M2M authentication.
    Handles token acquisition and caching to avoid unnecessary API calls.
    """

    def __init__(self, base_url: str = None):
        """
        Initialize the Auth Service Client.

        Args:
            base_url: Base URL for the Auth Service API, defaults to the value in settings
        """
        self.base_url = base_url or settings.AUTH_SERVICE_URL
        self.client_id = settings.M2M_CLIENT_ID
        self.client_secret = settings.M2M_CLIENT_SECRET

        # Token cache
        self._token: Optional[str] = None
        self._token_expiry: Optional[datetime] = None

    async def get_token(self, force_refresh: bool = False) -> str:
        """
        Get an M2M JWT token for authenticating with other services.
        If a valid token exists in the cache, return it, otherwise fetch a new one.

        Args:
            force_refresh: Force token refresh even if the current token is still valid

        Returns:
            str: The JWT token to use for authentication

        Raises:
            HTTPException: If token acquisition fails
        """
        if (
            not force_refresh
            and self._token
            and self._token_expiry
            and datetime.utcnow() < self._token_expiry
        ):
            logger.debug("Using cached auth token")
            return self._token

        logger.info("Fetching new M2M token from Auth Service")

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/auth/token",
                    json={
                        "client_id": self.client_id,
                        "client_secret": self.client_secret,
                        "grant_type": "client_credentials",  # Required by OAuth2 spec
                    },
                    timeout=10.0,
                )

                response.raise_for_status()
                data = response.json()

                self._token = data["access_token"]
                # Set expiry 1 minute before actual expiry to avoid edge cases
                expires_in = data.get("expires_in", 1800)  # Default to 30 minutes
                self._token_expiry = datetime.utcnow() + timedelta(
                    seconds=expires_in - 60
                )

                logger.info(
                    f"Successfully acquired new M2M token, valid until {self._token_expiry}"
                )
                return self._token
        except httpx.HTTPError as e:
            logger.error(f"Failed to acquire M2M token: {str(e)}")
            # Clear token cache in case of error
            self._token = None
            self._token_expiry = None
            raise

    async def get_auth_header(self, force_refresh: bool = False) -> Dict[str, str]:
        """
        Get the Authorization header with a valid JWT token.
        
        Args:
            force_refresh: Force token refresh even if the current token is still valid

        Returns:
            Dict[str, str]: Header with Authorization Bearer token
        """
        token = await self.get_token(force_refresh=force_refresh)
        return {"Authorization": f"Bearer {token}"}


# Create a global instance of the auth service client
auth_service_client = AuthServiceClient()


# data_capture_rightmove_service/src/data_capture_rightmove_service/utils/property_mapper.py
"""
Utility functions for mapping between API response data and database models
for Rightmove property data.
"""

from typing import Dict, Any, List, Optional


def camel_to_snake(name: str) -> str:
    """Convert camelCase string to snake_case."""
    import re
    return re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()


def map_property_data(data: Dict[str, Any], model_class) -> Dict[str, Any]:
    """
    Map API response data to ORM model fields by checking the column attributes.
    
    Args:
        data: API response data (usually in camelCase)
        model_class: The SQLAlchemy model class
    
    Returns:
        Dict with keys matching the ORM model attributes
    """
    result = {}
    
    # Get model attributes and their corresponding column names
    # This maps python attribute names to SQL column names
    model_columns = {}
    for column_attr in model_class.__table__.columns:
        # If there's a specified name in the Column definition, use it
        # Otherwise use the attribute name
        attr_name = column_attr.name
        if hasattr(column_attr, 'name') and getattr(column_attr, 'name') != attr_name:
            sql_name = getattr(column_attr, 'name')
        else:
            sql_name = attr_name
        model_columns[attr_name] = sql_name
    
    # Try different mappings for each field in data
    for key, value in data.items():
        # First check if the key exists directly in model
        if key in model_columns:
            result[key] = value
        # Then try snake_case version of camelCase key
        else:
            snake_key = camel_to_snake(key)
            if snake_key in model_columns:
                result[snake_key] = value
        
    return result


def map_nested_data(data: Dict[str, Any], model_mapping: Dict[str, Any]) -> Dict[str, Dict[str, Any]]:
    """
    Map nested API response data to ORM models for relationships.
    
    Args:
        data: API response data (usually in camelCase)
        model_mapping: Dict mapping from data keys to model classes
    
    Returns:
        Dict with keys matching the relationship names and values as mapped data
    """
    result = {}
    
    for data_key, model_class in model_mapping.items():
        if data_key in data and data[data_key] is not None:
            result[data_key] = map_property_data(data[data_key], model_class)
    
    return result


# data_capture_rightmove_service/src/data_capture_rightmove_service/utils/rate_limiting.py
"""
Rate limiting configuration for Data Capture Rightmove Service.
"""

from typing import Callable, Optional

from fastapi import Request, Response
from slowapi import Limiter
from slowapi.util import get_remote_address

from data_capture_rightmove_service.config import settings
from data_capture_rightmove_service.utils.logging_config import logger


def get_key_function() -> Callable:
    """
    Return the appropriate key function for rate limiting.

    In production, this would use the client IP or API key.
    In development, it uses a fixed value for easier testing.

    Returns:
        A function that extracts the rate limiting key from the request
    """
    if settings.is_development() or settings.is_testing():
        # Use a constant key in development for easier testing
        logger.debug("Using development rate limiting key function")
        return lambda _: "development"
    else:
        # Use client IP in production
        logger.debug("Using production rate limiting key function based on client IP")
        return get_remote_address


# Initialize the rate limiter with the appropriate key function
limiter = Limiter(key_func=get_key_function())


def configure_rate_limiter(request: Request, response: Response) -> None:
    """
    Configure rate limiter for the current request.

    Args:
        request: FastAPI request object
        response: FastAPI response object
    """
    # Add rate limiting headers to the response
    response.headers["X-RateLimit-Limit"] = str(settings.RATE_LIMIT_REQUESTS_PER_MINUTE)

    # Additional rate limiting configuration can be added here
    if hasattr(request.state, "rate_limit_remaining"):
        response.headers["X-RateLimit-Remaining"] = str(
            request.state.rate_limit_remaining
        )

    if hasattr(request.state, "rate_limit_reset"):
        response.headers["X-RateLimit-Reset"] = str(request.state.rate_limit_reset)

    # Log rate limiting information in debug mode
    logger.debug(
        f"Rate limiting applied to {request.method} {request.url.path} "
        f"from {get_remote_address(request)}"
    )


# data_capture_rightmove_service/src/data_capture_rightmove_service/utils/logging_config.py
import json
import logging
import sys
import time
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, Optional

from fastapi import FastAPI, Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

from data_capture_rightmove_service.config import Environment, settings

# Configure logger
logger = logging.getLogger("data_capture_rightmove_service")


# Request ID context for correlating log entries from the same request
class RequestContext:
    """Thread-local storage for request context such as request ID"""

    _request_id: Optional[str] = None

    @classmethod
    def get_request_id(cls) -> Optional[str]:
        return cls._request_id

    @classmethod
    def set_request_id(cls, request_id: str) -> None:
        cls._request_id = request_id

    @classmethod
    def clear_request_id(cls) -> None:
        cls._request_id = None


class RequestIdMiddleware(BaseHTTPMiddleware):
    """Middleware to add request ID to each request"""

    async def dispatch(self, request: Request, call_next):
        request_id = request.headers.get("X-Request-ID") or str(uuid.uuid4())
        RequestContext.set_request_id(request_id)
        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id
        RequestContext.clear_request_id()
        return response


class JsonFormatter(logging.Formatter):
    """Custom JSON formatter for structured logging"""

    def format(self, record: logging.LogRecord) -> str:
        log_record = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
            # --- FIX: Use uppercase attribute ---
            "environment": str(settings.ENVIRONMENT.value),
        }
        if request_id := RequestContext.get_request_id():
            log_record["request_id"] = request_id
        if record.exc_info:
            log_record["exception"] = self.formatException(record.exc_info)
        if hasattr(record, "extra") and record.extra:
            log_record.update(record.extra)
        return json.dumps(log_record)


# For backward compatibility with imports
def configure_logging():
    """Configure logging for non-FastAPI applications like Alembic"""
    setup_logging()


def setup_logging(app: FastAPI = None) -> None:
    """Configure logging for the application

    Args:
        app: Optional FastAPI application to add middleware to.
             If None, only configures logging without middleware.
    """
    # --- FIX: Use uppercase attribute ---
    log_level = getattr(logging, settings.LOGGING_LEVEL.upper(), logging.INFO)

    root_logger = logging.getLogger()
    if root_logger.hasHandlers():
        root_logger.handlers.clear()

    # --- FIX: Use uppercase attribute ---
    if settings.ENVIRONMENT == Environment.PRODUCTION:
        formatter = JsonFormatter()
    else:
        formatter = logging.Formatter(
            "%(asctime)s - %(levelname)s - %(name)s - %(message)s"
        )

    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    root_logger.addHandler(console_handler)
    root_logger.setLevel(log_level)

    # Configure specific loggers if needed
    logging.getLogger("auth_service").setLevel(log_level)
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)

    # Only add middleware if app is provided
    if app:
        app.add_middleware(RequestIdMiddleware)
        logger.info(
            # --- FIX: Use uppercase attribute ---
            f"Logging configured with level {settings.LOGGING_LEVEL} "
            f"and {'JSON' if settings.ENVIRONMENT == Environment.PRODUCTION else 'plain text'} format"
        )


class LoggingMiddleware(BaseHTTPMiddleware):
    """Middleware to log request and response information"""

    async def dispatch(self, request: Request, call_next):
        if request.url.path in ["/health", "/internal/health"]:
            return await call_next(request)

        start_time = time.time()
        request_id = RequestContext.get_request_id()

        try:
            response = await call_next(request)
            duration_ms = (time.time() - start_time) * 1000

            logger.info(
                "Request processed",
                extra={
                    "request": {
                        "method": request.method,
                        "path": request.url.path,
                        "client_host": request.client.host,
                        "request_id": request_id,
                    },
                    "response": {
                        "status_code": response.status_code,
                        "duration_ms": round(duration_ms, 2),
                    },
                },
            )
            return response
        except Exception as e:
            logger.error(
                f"Request failed: {e}", exc_info=True, extra={"request_id": request_id}
            )
            raise


# data_capture_rightmove_service/src/data_capture_rightmove_service/utils/security.py
"""
Security utilities for Data Capture Rightmove Service.
"""

import time
from typing import Dict, Optional

import jwt
from fastapi import Depends, HTTPException, Security
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer

from data_capture_rightmove_service.config import settings
from data_capture_rightmove_service.utils.logging_config import logger

security = HTTPBearer(auto_error=False)


async def validate_token(
    credentials: Optional[HTTPAuthorizationCredentials] = Security(security),
) -> Dict:
    """
    Validate JWT token from Authorization header.

    Args:
        credentials: JWT credentials from Authorization header

    Returns:
        Dict containing token claims

    Raises:
        HTTPException: If token is invalid or expired
    """
    if not credentials:
        logger.warning("Missing authentication token")
        raise HTTPException(
            status_code=401,
            detail="Missing authentication token",
            headers={"WWW-Authenticate": "Bearer"},
        )

    token = credentials.credentials

    try:
        # Validate the token
        payload = jwt.decode(
            token,
            settings.M2M_CLIENT_SECRET,
            algorithms=["HS256"],
            options={"verify_signature": True},
        )

        # Check if token has expired
        if payload.get("exp") and payload["exp"] < time.time():
            logger.warning(f"Token has expired: {payload.get('sub', 'unknown')}")
            raise HTTPException(
                status_code=401,
                detail="Token has expired",
                headers={"WWW-Authenticate": "Bearer"},
            )

        logger.debug(
            f"Successfully validated token for: {payload.get('sub', 'unknown')}"
        )
        return payload

    except jwt.ExpiredSignatureError:
        logger.warning("Token signature has expired")
        raise HTTPException(
            status_code=401,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.InvalidTokenError as e:
        logger.warning(f"Invalid token: {str(e)}")
        raise HTTPException(
            status_code=401,
            detail=f"Invalid token: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"},
        )


async def get_current_service(
    token_data: Dict = Depends(validate_token),
) -> str:
    """
    Get the service name from the authenticated token.

    Args:
        token_data: Validated token data

    Returns:
        Service name from token

    Raises:
        HTTPException: If service is not found in token
    """
    if "service" not in token_data:
        logger.warning("Invalid token claims: service missing")
        raise HTTPException(
            status_code=401, detail="Invalid token claims: service missing"
        )

    service = token_data["service"]
    logger.debug(f"Authenticated service: {service}")
    return service


async def requires_scope(
    required_scope: str, token_data: Dict = Depends(validate_token)
) -> bool:
    """
    Check if token has the required scope.

    Args:
        required_scope: Scope required for access
        token_data: Validated token data

    Returns:
        True if token has required scope

    Raises:
        HTTPException: If token does not have required scope
    """
    if "scope" not in token_data:
        logger.warning("Token missing scope claim")
        raise HTTPException(
            status_code=403, detail="Insufficient permissions: missing scope claim"
        )

    scopes = token_data["scope"].split()

    if required_scope not in scopes:
        logger.warning(f"Token missing required scope: {required_scope}")
        raise HTTPException(
            status_code=403,
            detail=f"Insufficient permissions: required scope '{required_scope}' not granted",
        )

    return True


# data_capture_rightmove_service/src/data_capture_rightmove_service/utils/__init__.py
"""
Utility modules for Data Capture Rightmove Service.

Exports utilities for logging, rate limiting, security, and other common functions.
"""

from data_capture_rightmove_service.utils.logging_config import (
    configure_logging,
    logger,
)
from data_capture_rightmove_service.utils.rate_limiting import limiter
from data_capture_rightmove_service.utils.security import (
    get_current_service,
    requires_scope,
    validate_token,
)

__all__ = [
    "configure_logging",
    "logger",
    "limiter",
    "validate_token",
    "get_current_service",
    "requires_scope",
]


# data_capture_rightmove_service/src/data_capture_rightmove_service/utils/url_parsing.py
"""
Utility functions for parsing URLs and extracting useful information.
"""

import re
from typing import Optional, Tuple
from urllib.parse import urlparse

# Regex pattern for extracting property ID from Rightmove URLs
# Matches patterns like:
# - https://www.rightmove.co.uk/properties/154508327
# - https://www.rightmove.co.uk/properties/154508327#/?channel=RES_LET
RIGHTMOVE_PROPERTY_ID_PATTERN = r"rightmove\.co\.uk/properties/(\d+)"


def extract_rightmove_property_id(url: str) -> Optional[int]:
    """
    Extract the property ID from a Rightmove URL.
    
    Args:
        url: A Rightmove property URL
        
    Returns:
        int: The extracted property ID, or None if not found
        
    Examples:
        >>> extract_rightmove_property_id("https://www.rightmove.co.uk/properties/154508327#/?channel=RES_LET")
        154508327
        >>> extract_rightmove_property_id("https://www.rightmove.co.uk/properties/123456789")
        123456789
    """
    if not url:
        return None
    
    # Parse URL to validate it's a proper URL
    try:
        parsed_url = urlparse(url)
        if not parsed_url.netloc or "rightmove.co.uk" not in parsed_url.netloc.lower():
            return None
    except Exception:
        return None
        
    # Extract property ID using regex
    match = re.search(RIGHTMOVE_PROPERTY_ID_PATTERN, url)
    if match and match.group(1):
        try:
            return int(match.group(1))
        except ValueError:
            return None
            
    return None


def is_valid_rightmove_url(url: str) -> bool:
    """
    Check if a URL is a valid Rightmove property URL.
    
    Args:
        url: URL to check
        
    Returns:
        bool: True if the URL is a valid Rightmove property URL, False otherwise
    """
    if not url:
        return False
        
    # First validate it's a proper URL with rightmove.co.uk domain
    try:
        parsed_url = urlparse(url)
        if not parsed_url.netloc or "rightmove.co.uk" not in parsed_url.netloc.lower():
            return False
    except Exception:
        return False
    
    # Check if it has a property ID
    return extract_rightmove_property_id(url) is not None


def determine_rightmove_api_endpoints(url: str) -> Tuple[str, str]:
    """
    Determine which Rightmove API endpoints to use based on the URL structure.
    
    Args:
        url: A Rightmove property URL
        
    Returns:
        Tuple[str, str]: A tuple of (primary_endpoint, secondary_endpoint)
        Where primary is the preferred endpoint to try first
    """
    if not url:
        return ("properties_details", "property_for_sale")
    
    # Default choice
    primary = "properties_details"
    secondary = "property_for_sale"
    
    # If the URL contains keywords indicating it's a property for sale,
    # prioritize the property-for-sale endpoint
    url_lower = url.lower()
    if "property-for-sale" in url_lower or "for-sale" in url_lower:
        primary, secondary = secondary, primary
    
    return (primary, secondary)


# data_capture_rightmove_service/src/data_capture_rightmove_service/utils/db_utils.py
"""
Database utility functions to help bridge the gap between API responses and database models.
"""

from typing import Dict, Any, Optional, Type
import logging

logger = logging.getLogger(__name__)

def normalize_model_instance(model_class, data: dict) -> dict:
    """
    Normalizes data for a model instance by mapping API response field names to model attributes.
    Handles cases where SQLAlchemy model attributes differ from database column names
    due to the use of the 'name' parameter in Column definitions.
    
    Args:
        model_class: SQLAlchemy model class
        data: Dictionary of data to normalize
        
    Returns:
        Dict of normalized data that can be passed to the model constructor
    """
    # Create a copy to avoid modifying the original
    normalized_data = data.copy()
    
    # Extract column information directly from SQLAlchemy model
    # This includes the Python attribute name and the actual DB column name mapping
    model_columns = {}
    python_attr_to_db_column = {}
    db_column_to_python_attr = {}
    
    # Build a list of all valid attribute names from the model class
    model_attrs = set()
    
    # Create mappings between API fields and Python attributes
    # First create a mapping of both ways between Python attributes and DB column names
    for column in model_class.__table__.columns:
        python_attr = column.key  # Python attribute name as defined in the model (e.g., brand_name)
        db_column = column.name   # DB column name (e.g., brandName)
        
        # Add to our set of valid model attribute names
        model_attrs.add(python_attr)
        
        # Store info about each column
        model_columns[python_attr] = {
            'type': str(column.type),
            'db_column': db_column
        }
        
        # Create bidirectional maps (case-insensitive for easier matching)
        python_attr_to_db_column[python_attr.lower()] = db_column
        db_column_to_python_attr[db_column.lower()] = python_attr
    
    logger.debug(f"Model {model_class.__name__} has {len(model_columns)} columns")
    logger.debug(f"Python attributes for {model_class.__name__}: {sorted(model_attrs)[:5]}...")
    
    # Create a clean dictionary with the correct attribute names
    clean_values = {}
    unmapped_keys = []
    
    # Process all fields from the input data
    for api_field, value in normalized_data.items():
        # Don't process keys we've already mapped
        if api_field in clean_values:
            continue
            
        # 1. Direct exact match with model Python attribute
        if api_field in model_attrs:
            clean_values[api_field] = value
            logger.debug(f"Direct match: API field '{api_field}' -> model attr '{api_field}'")
            continue
            
        # 2. Try to match with DB column names (which may differ from Python attributes)
        api_field_lower = api_field.lower()
        if api_field_lower in db_column_to_python_attr:
            # Found a match where API field matches a DB column name
            attr_name = db_column_to_python_attr[api_field_lower]
            if attr_name not in clean_values:  # Don't overwrite direct matches
                logger.debug(f"DB column match: API field '{api_field}' -> model attr '{attr_name}'")
                clean_values[attr_name] = value
            continue
                
        # 3. Case-insensitive match with model attributes
        matching_attrs = [attr for attr in model_attrs if attr.lower() == api_field_lower]
        if matching_attrs:
            attr_name = matching_attrs[0]  # Use the first match
            if attr_name not in clean_values:
                logger.debug(f"Case-insensitive match: API field '{api_field}' -> model attr '{attr_name}'")
                clean_values[attr_name] = value
            continue
                
        # If we get here, we couldn't map this field at all
        unmapped_keys.append(api_field)
    
    # Log any unmapped keys
    if unmapped_keys:
        logger.debug(f"Unmapped keys for {model_class.__name__}: {unmapped_keys[:10]}...")
    
    # Special handling for known types
    for attr_name in list(clean_values.keys()):
        value = clean_values[attr_name]
        
        # Handle array fields
        if 'ARRAY' in model_columns.get(attr_name, {}).get('type', ''):
            if value is None:
                clean_values[attr_name] = []
            elif isinstance(value, str):
                clean_values[attr_name] = [value]
            elif not isinstance(value, list):
                try:
                    clean_values[attr_name] = list(value)
                except Exception as e:
                    logger.warning(f"Could not convert {attr_name} to list: {str(e)}, using empty list")
                    clean_values[attr_name] = []
        
        # Handle JSON/JSONB fields
        elif 'JSON' in model_columns.get(attr_name, {}).get('type', ''):
            if not isinstance(value, dict) and value is not None:
                try:
                    if isinstance(value, str):
                        import json
                        clean_values[attr_name] = json.loads(value)
                    else:
                        clean_values[attr_name] = dict(value)
                except Exception as e:
                    logger.warning(f"Could not convert {attr_name} to dict: {str(e)}, using empty dict")
                    clean_values[attr_name] = {}
    
    return clean_values


# data_capture_rightmove_service/src/data_capture_rightmove_service/models/__init__.py
"""
Database models for the Data Capture Rightmove Service.
"""

from data_capture_rightmove_service.models.base import Base, SuperIdMixin
from data_capture_rightmove_service.models.properties_details_v2 import (
    ApiPropertiesDetailsV2,
    ApiPropertiesDetailsV2Branch,
    ApiPropertiesDetailsV2Floorplan,
    ApiPropertiesDetailsV2Location,
    ApiPropertiesDetailsV2Photo,
    ApiPropertiesDetailsV2Price,
    ApiPropertiesDetailsV2Station,
)
from data_capture_rightmove_service.models.property_details import (
    ApiPropertyDetailCustomer,
    ApiPropertyDetailFloorplan,
    ApiPropertyDetailImage,
    ApiPropertyDetailPrice,
    ApiPropertyDetails,
)

# Export all models
__all__ = [
    "Base",
    "SuperIdMixin",
    "ApiPropertiesDetailsV2",
    "ApiPropertiesDetailsV2Branch",
    "ApiPropertiesDetailsV2Price",
    "ApiPropertiesDetailsV2Location",
    "ApiPropertiesDetailsV2Photo",
    "ApiPropertiesDetailsV2Floorplan",
    "ApiPropertiesDetailsV2Station",
    "ApiPropertyDetails",
    "ApiPropertyDetailPrice",
    "ApiPropertyDetailCustomer",
    "ApiPropertyDetailImage",
    "ApiPropertyDetailFloorplan",
]


# data_capture_rightmove_service/src/data_capture_rightmove_service/models/property_details.py
"""
Models for the Rightmove property-for-sale/detail API endpoint data.
"""

from sqlalchemy import (
    ARRAY,
    TIMESTAMP,
    BigInteger,
    Boolean,
    Column,
    Float,
    ForeignKey,
    Integer,
    String,
    Text,
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship
from sqlalchemy.types import Numeric

from data_capture_rightmove_service.models.base import Base, SuperIdMixin


class ApiPropertyDetails(Base, SuperIdMixin):
    """
    Main table for storing property details from the property-for-sale/detail API.
    Maps to rightmove.api_property_details table.
    """

    __tablename__ = "api_property_details"

    id = Column(BigInteger, primary_key=True)
    affordable_buying_scheme = Column(Boolean, name="affordableBuyingScheme")
    ai_location_info = Column(Text, name="aiLocationInfo")
    bathrooms = Column(Integer)
    bedrooms = Column(Integer)
    business_for_sale = Column(Boolean, name="businessForSale")
    channel = Column(String(50))
    commercial = Column(Boolean)
    country_guide = Column(Text, name="countryGuide")
    enc_id = Column(Text, name="encId")
    fees_apply = Column(Text, name="feesApply")
    lettings = Column(Text)
    property_sub_type = Column(Text, name="propertySubType")
    show_school_info = Column(Boolean, name="showSchoolInfo")
    sold_property_type = Column(String(100), name="soldPropertyType")
    terms_of_use = Column(Text, name="termsOfUse")
    transaction_type = Column(String(50), name="transactionType")
    brochures = Column(JSONB)
    commercial_use_classes = Column(ARRAY(Text), name="commercialUseClasses")
    epc_graphs = Column(JSONB, name="epcGraphs")
    key_features = Column(ARRAY(Text), name="keyFeatures")
    nearest_airports = Column(ARRAY(Text), name="nearestAirports")
    rooms = Column(ARRAY(Text))
    sizings = Column(JSONB)
    tags = Column(ARRAY(Text))

    # Relationships
    address = relationship(
        "ApiPropertyDetailAddress", back_populates="property", uselist=False
    )
    broadband = relationship(
        "ApiPropertyDetailBroadband", back_populates="property", uselist=False
    )
    contact_info = relationship(
        "ApiPropertyDetailContactInfo", back_populates="property", uselist=False
    )
    customer = relationship(
        "ApiPropertyDetailCustomer", back_populates="property", uselist=False
    )
    dfp_ad_info = relationship(
        "ApiPropertyDetailDfpAdInfo", back_populates="property", uselist=False
    )
    floorplans = relationship("ApiPropertyDetailFloorplan", back_populates="property")
    images = relationship("ApiPropertyDetailImage", back_populates="property")
    industry_affiliations = relationship(
        "ApiPropertyDetailIndustryAffiliation", back_populates="property"
    )
    info_reel_items = relationship(
        "ApiPropertyDetailInfoReelItem", back_populates="property"
    )
    listing_history = relationship(
        "ApiPropertyDetailListingHistory", back_populates="property", uselist=False
    )
    living_costs = relationship(
        "ApiPropertyDetailLivingCost", back_populates="property", uselist=False
    )
    location = relationship(
        "ApiPropertyDetailLocation", back_populates="property", uselist=False
    )
    mis_info = relationship(
        "ApiPropertyDetailMisInfo", back_populates="property", uselist=False
    )
    mortgage_calculator = relationship(
        "ApiPropertyDetailMortgageCalculator", back_populates="property", uselist=False
    )
    nearest_stations = relationship(
        "ApiPropertyDetailNearestStation", back_populates="property"
    )
    price = relationship(
        "ApiPropertyDetailPrice", back_populates="property", uselist=False
    )
    property_urls = relationship(
        "ApiPropertyDetailPropertyUrl", back_populates="property", uselist=False
    )
    shared_ownership = relationship(
        "ApiPropertyDetailSharedOwnership", back_populates="property", uselist=False
    )
    static_map_img_url = relationship(
        "ApiPropertyDetailStaticMapImgUrl", back_populates="property", uselist=False
    )
    status = relationship(
        "ApiPropertyDetailStatus", back_populates="property", uselist=False
    )
    street_view = relationship(
        "ApiPropertyDetailStreetView", back_populates="property", uselist=False
    )
    tenure = relationship(
        "ApiPropertyDetailTenure", back_populates="property", uselist=False
    )
    text = relationship(
        "ApiPropertyDetailText", back_populates="property", uselist=False
    )


class ApiPropertyDetailAddress(Base, SuperIdMixin):
    """
    Table for storing address information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_addresses table.
    """

    __tablename__ = "api_property_detail_addresses"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    country_code = Column(String(10), name="countryCode")
    delivery_point_id = Column(BigInteger, name="deliveryPointId")
    display_address = Column(Text, name="displayAddress")
    incode = Column(String(10))
    outcode = Column(String(10))
    uk_country = Column(String(100), name="ukCountry")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="address")


class ApiPropertyDetailBroadband(Base, SuperIdMixin):
    """
    Table for storing broadband information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_broadbands table.
    """

    __tablename__ = "api_property_detail_broadbands"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    broadband_checker_url = Column(Text, name="broadbandCheckerUrl")
    disclaimer = Column(Text)

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="broadband")


class ApiPropertyDetailContactInfo(Base, SuperIdMixin):
    """
    Table for storing contact information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_contact_infos table.
    """

    __tablename__ = "api_property_detail_contact_infos"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    contact_method = Column(String(100), name="contactMethod")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="contact_info")
    telephone_number = relationship(
        "ApiPropertyDetailContactInfoTelephonenumber",
        back_populates="contact_info",
        uselist=False,
    )


class ApiPropertyDetailContactInfoTelephonenumber(Base, SuperIdMixin):
    """
    Table for storing telephone number information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_contactinfo_telephonenumbers table.
    """

    __tablename__ = "api_property_detail_contactinfo_telephonenumbers"

    contact_info_detail_id = Column(
        BigInteger,
        ForeignKey(
            "rightmove.api_property_detail_contact_infos.api_property_detail_id",
            ondelete="CASCADE",
        ),
        primary_key=True,
    )
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    disclaimer_description = Column(Text, name="disclaimerDescription")
    disclaimer_text = Column(Text, name="disclaimerText")
    disclaimer_title = Column(Text, name="disclaimerTitle")
    international_number = Column(String(50), name="internationalNumber")
    local_number = Column(String(50), name="localNumber")

    # Relationships
    contact_info = relationship(
        "ApiPropertyDetailContactInfo", back_populates="telephone_number"
    )


class ApiPropertyDetailCustomer(Base, SuperIdMixin):
    """
    Table for storing customer information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_customers table.
    """

    __tablename__ = "api_property_detail_customers"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    banner_ad = Column(Text, name="bannerAd")
    branch_display_name = Column(String(255), name="branchDisplayName")
    branch_id = Column(Integer, name="branchId")
    branch_name = Column(String(255), name="branchName")
    build_to_rent = Column(Boolean, name="buildToRent")
    build_to_rent_benefits = Column(ARRAY(Text), name="buildToRentBenefits")
    commercial = Column(Boolean)
    company_name = Column(String(255), name="companyName")
    company_trading_name = Column(String(255), name="companyTradingName")
    customer_banner_ad_profile_url = Column(Text, name="customerBannerAdProfileUrl")
    customer_mpu_ad_profile_url = Column(Text, name="customerMpuAdProfileUrl")
    customer_profile_url = Column(Text, name="customerProfileUrl")
    customer_properties_url = Column(Text, name="customerPropertiesUrl")
    display_address = Column(Text, name="displayAddress")
    is_new_home_developer = Column(Boolean, name="isNewHomeDeveloper")
    logo_path = Column(Text, name="logoPath")
    mpu_ad = Column(Text, name="mpuAd")
    show_brochure_lead_modal = Column(Boolean, name="showBrochureLeadModal")
    spotlight = Column(Text)
    valuation_form_url = Column(Text, name="valuationFormUrl")
    video_enabled = Column(Boolean, name="videoEnabled")
    video_url = Column(Text, name="videoUrl")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="customer")
    description = relationship(
        "ApiPropertyDetailCustomerDescription", back_populates="customer", uselist=False
    )
    development_info = relationship(
        "ApiPropertyDetailCustomerDevelopmentInfo",
        back_populates="customer",
        uselist=False,
    )
    products = relationship(
        "ApiPropertyDetailCustomerProduct", back_populates="customer", uselist=False
    )


class ApiPropertyDetailCustomerDescription(Base, SuperIdMixin):
    """
    Table for storing customer description information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_customer_descriptions table.
    """

    __tablename__ = "api_property_detail_customer_descriptions"

    customer_api_property_detail_id = Column(
        BigInteger,
        ForeignKey(
            "rightmove.api_property_detail_customers.api_property_detail_id",
            ondelete="CASCADE",
        ),
        primary_key=True,
    )
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    description_html = Column(Text, name="descriptionHTML")
    is_truncated = Column(Boolean, name="isTruncated")
    truncated_description_html = Column(Text, name="truncatedDescriptionHTML")

    # Relationships
    customer = relationship("ApiPropertyDetailCustomer", back_populates="description")


class ApiPropertyDetailCustomerDevelopmentInfo(Base, SuperIdMixin):
    """
    Table for storing customer development information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_customer_development_infos table.
    """

    __tablename__ = "api_property_detail_customer_development_infos"

    customer_api_property_detail_id = Column(
        BigInteger,
        ForeignKey(
            "rightmove.api_property_detail_customers.api_property_detail_id",
            ondelete="CASCADE",
        ),
        primary_key=True,
    )
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    site_plan_uri = Column(Text, name="sitePlanUri")
    microsite_features = Column(ARRAY(Text), name="micrositeFeatures")

    # Relationships
    customer = relationship(
        "ApiPropertyDetailCustomer", back_populates="development_info"
    )


class ApiPropertyDetailCustomerProduct(Base, SuperIdMixin):
    """
    Table for storing customer product information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_customer_products table.
    """

    __tablename__ = "api_property_detail_customer_products"

    customer_api_property_detail_id = Column(
        BigInteger,
        ForeignKey(
            "rightmove.api_property_detail_customers.api_property_detail_id",
            ondelete="CASCADE",
        ),
        primary_key=True,
    )
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    has_microsite = Column(Boolean, name="hasMicrosite")

    # Relationships
    customer = relationship("ApiPropertyDetailCustomer", back_populates="products")


class ApiPropertyDetailDfpAdInfo(Base, SuperIdMixin):
    """
    Table for storing DFP ad information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_dfp_ad_infos table.
    """

    __tablename__ = "api_property_detail_dfp_ad_infos"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    channel = Column(String(50))
    targeting = Column(JSONB)

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="dfp_ad_info")


class ApiPropertyDetailFloorplan(Base, SuperIdMixin):
    """
    Table for storing floorplan information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_floorplans table.
    """

    __tablename__ = "api_property_detail_floorplans"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    caption = Column(String(255))
    type = Column(String(50))
    url = Column(Text)

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="floorplans")
    resized_floorplan_url = relationship(
        "ApiPropertyDetailFloorplanResizedFloorplanUrl",
        back_populates="floorplan",
        uselist=False,
    )


class ApiPropertyDetailFloorplanResizedFloorplanUrl(Base, SuperIdMixin):
    """
    Table for storing resized floorplan URL information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_floorplan_resized_floorplan_urls table.
    """

    __tablename__ = "api_property_detail_floorplan_resized_floorplan_urls"

    floorplan_id = Column(
        Integer,
        ForeignKey("rightmove.api_property_detail_floorplans.id", ondelete="CASCADE"),
        primary_key=True,
    )
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    size296x197 = Column(Text)

    # Relationships
    floorplan = relationship(
        "ApiPropertyDetailFloorplan", back_populates="resized_floorplan_url"
    )


class ApiPropertyDetailImage(Base, SuperIdMixin):
    """
    Table for storing image information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_images table.
    """

    __tablename__ = "api_property_detail_images"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    caption = Column(String(255))
    url = Column(Text)

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="images")
    resized_image_url = relationship(
        "ApiPropertyDetailImageResizedImageUrl", back_populates="image", uselist=False
    )


class ApiPropertyDetailImageResizedImageUrl(Base, SuperIdMixin):
    """
    Table for storing resized image URL information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_image_resized_image_urls table.
    """

    __tablename__ = "api_property_detail_image_resized_image_urls"

    image_id = Column(
        Integer,
        ForeignKey("rightmove.api_property_detail_images.id", ondelete="CASCADE"),
        primary_key=True,
    )
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    size135x100 = Column(Text)
    size476x317 = Column(Text)
    size656x437 = Column(Text)

    # Relationships
    image = relationship("ApiPropertyDetailImage", back_populates="resized_image_url")


class ApiPropertyDetailIndustryAffiliation(Base, SuperIdMixin):
    """
    Table for storing industry affiliation information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_industry_affiliations table.
    """

    __tablename__ = "api_property_detail_industry_affiliations"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    image_path = Column(Text, name="image_path")
    name = Column(Text)

    # Relationships
    property = relationship(
        "ApiPropertyDetails", back_populates="industry_affiliations"
    )


class ApiPropertyDetailInfoReelItem(Base, SuperIdMixin):
    """
    Table for storing info reel item information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_info_reel_items table.
    """

    __tablename__ = "api_property_detail_info_reel_items"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    primary_text = Column(Text, name="primary_text")
    secondary_text = Column(Text, name="secondary_text")
    title = Column(Text)
    tooltip_text = Column(Text, name="tooltip_text")
    type = Column(Text)

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="info_reel_items")


class ApiPropertyDetailListingHistory(Base, SuperIdMixin):
    """
    Table for storing listing history information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_listing_history table.
    """

    __tablename__ = "api_property_detail_listing_history"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    listing_update_reason = Column(Text, name="listingUpdateReason")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="listing_history")


class ApiPropertyDetailLivingCost(Base, SuperIdMixin):
    """
    Table for storing living cost information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_living_costs table.
    """

    __tablename__ = "api_property_detail_living_costs"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    annual_ground_rent = Column(Text, name="annualGroundRent")
    annual_service_charge = Column(Text, name="annualServiceCharge")
    council_tax_band = Column(String(10), name="councilTaxBand")
    council_tax_exempt = Column(Boolean, name="councilTaxExempt")
    council_tax_included = Column(Boolean, name="councilTaxIncluded")
    domestic_rates = Column(Text, name="domesticRates")
    ground_rent_percentage_increase = Column(Text, name="groundRentPercentageIncrease")
    ground_rent_review_period_in_years = Column(
        Text, name="groundRentReviewPeriodInYears"
    )

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="living_costs")


class ApiPropertyDetailLocation(Base, SuperIdMixin):
    """
    Table for storing location information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_locations table.
    """

    __tablename__ = "api_property_detail_locations"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    circle_radius_on_map = Column(Integer, name="circleRadiusOnMap")
    latitude = Column(Numeric(10, 8))
    longitude = Column(Numeric(11, 8))
    pin_type = Column(String(50), name="pinType")
    show_map = Column(Boolean, name="showMap")
    zoom_level = Column(Integer, name="zoomLevel")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="location")


class ApiPropertyDetailMisInfo(Base, SuperIdMixin):
    """
    Table for storing MIS information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_mis_infos table.
    """

    __tablename__ = "api_property_detail_mis_infos"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    branch_id = Column(Integer, name="branchId")
    brand_plus = Column(Boolean, name="brandPlus")
    featured_property = Column(Boolean, name="featuredProperty")
    offer_advert_stamp_type_id = Column(Text, name="offerAdvertStampTypeId")
    premium_display = Column(Boolean, name="premiumDisplay")
    premium_display_stamp_id = Column(Text, name="premiumDisplayStampId")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="mis_info")


class ApiPropertyDetailMortgageCalculator(Base, SuperIdMixin):
    """
    Table for storing mortgage calculator information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_mortgage_calculators table.
    """

    __tablename__ = "api_property_detail_mortgage_calculators"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    enabled = Column(Boolean)
    full_calculator_url = Column(Text, name="fullCalculatorUrl")
    help_to_buy = Column(Boolean, name="helpToBuy")
    monthly_payment = Column(Numeric(10, 2), name="monthlyPayment")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="mortgage_calculator")


class ApiPropertyDetailNearestStation(Base, SuperIdMixin):
    """
    Table for storing nearest station information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_nearest_stations table.
    """

    __tablename__ = "api_property_detail_nearest_stations"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        nullable=False,
    )
    distance_in_miles = Column(Numeric(10, 2), name="distanceInMiles")
    name = Column(String(255))

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="nearest_stations")


class ApiPropertyDetailPrice(Base, SuperIdMixin):
    """
    Table for storing price information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_prices table.
    """

    __tablename__ = "api_property_detail_prices"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    currency_code = Column(String(3), name="currencyCode")
    display_price = Column(String(255), name="displayPrice")
    display_prices = Column(JSONB, name="displayPrices")
    price_qualifier = Column(String(100), name="priceQualifier")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="price")


class ApiPropertyDetailPropertyUrl(Base, SuperIdMixin):
    """
    Table for storing property URL information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_property_urls table.
    """

    __tablename__ = "api_property_detail_property_urls"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    full_property_url = Column(Text, name="fullPropertyUrl")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="property_urls")


class ApiPropertyDetailSharedOwnership(Base, SuperIdMixin):
    """
    Table for storing shared ownership information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_shared_ownerships table.
    """

    __tablename__ = "api_property_detail_shared_ownerships"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    minimum_share_price = Column(Numeric(10, 2), name="minimumSharePrice")
    minimum_share_percentage = Column(Numeric(5, 2), name="minimumSharePercentage")
    rental_price_pcm = Column(Numeric(10, 2), name="rentalPricePcm")
    shared_ownership_headline = Column(Text, name="sharedOwnershipHeadline")
    total_property_value = Column(Numeric(10, 2), name="totalPropertyValue")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="shared_ownership")


class ApiPropertyDetailStaticMapImgUrl(Base, SuperIdMixin):
    """
    Table for storing static map image URL information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_static_map_img_urls table.
    """

    __tablename__ = "api_property_detail_static_map_img_urls"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    url = Column(Text)

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="static_map_img_url")


class ApiPropertyDetailStatus(Base, SuperIdMixin):
    """
    Table for storing status information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_statuses table.
    """

    __tablename__ = "api_property_detail_statuses"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    published = Column(Boolean)
    saved = Column(Boolean)

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="status")


class ApiPropertyDetailStreetView(Base, SuperIdMixin):
    """
    Table for storing street view information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_street_views table.
    """

    __tablename__ = "api_property_detail_street_views"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    coordinate_heading = Column(Numeric(10, 6), name="coordinateHeading")
    coordinate_pitch = Column(Numeric(10, 6), name="coordinatePitch")
    coordinate_zoom = Column(Numeric(10, 6), name="coordinateZoom")
    latitude = Column(Numeric(10, 8))
    longitude = Column(Numeric(11, 8))

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="street_view")


class ApiPropertyDetailTenure(Base, SuperIdMixin):
    """
    Table for storing tenure information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_tenures table.
    """

    __tablename__ = "api_property_detail_tenures"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    has_shared_ownership = Column(Boolean, name="hasSharedOwnership")
    tenure_type = Column(String(100), name="tenureType")

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="tenure")


class ApiPropertyDetailText(Base, SuperIdMixin):
    """
    Table for storing text information from the property-for-sale/detail API.
    Maps to rightmove.api_property_detail_texts table.
    """

    __tablename__ = "api_property_detail_texts"

    api_property_detail_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_property_details.id", ondelete="CASCADE"),
        primary_key=True,
    )
    bullet_counts = Column(JSONB, name="bulletCounts")
    floors = Column(JSONB)

    # Relationships
    property = relationship("ApiPropertyDetails", back_populates="text")


# data_capture_rightmove_service/src/data_capture_rightmove_service/models/properties_details_v2.py
"""
Models for the Rightmove properties/details v2 API endpoint data.
This module defines SQLAlchemy models that map to the tables in the rightmove schema.
"""

from sqlalchemy import (
    ARRAY,
    TIMESTAMP,
    BigInteger,
    Boolean,
    Column,
    Float,
    ForeignKey,
    Integer,
    Numeric,
    String,
    Text,
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship

from data_capture_rightmove_service.models.base import Base, SuperIdMixin


class ApiPropertiesDetailsV2(Base, SuperIdMixin):
    """
    Main table for storing property details from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2 table.
    """

    __tablename__ = "api_properties_details_v2"

    id = Column(BigInteger, primary_key=True)
    transaction_type = Column(String(50), name="transactiontype")
    channel = Column(String(50))
    bedrooms = Column(Integer)
    bathrooms = Column(Integer)
    address = Column(Text)
    contact_method = Column(String(50), name="contactmethod")
    property_disclaimer = Column(Text, name="propertydisclaimer")
    property_phrase = Column(String(255), name="propertyphrase")
    full_description = Column(Text, name="fulldescription")
    listing_update_reason = Column(String(255), name="listingupdatereason")
    property_url = Column(Text, name="propertyurl")
    school_checker_url = Column(Text, name="schoolcheckerurl")
    lettings_info = Column(Text, name="lettingsinfo")
    property_display_type = Column(String(100), name="propertydisplaytype")
    telephone_number = Column(String(50), name="telephonenumber")
    saved = Column(Boolean)
    sold_prices_url = Column(Text, name="soldpricesurl")
    market_info_url = Column(Text, name="marketinfourl")
    note = Column(Text)
    link_to_glossary = Column(Text, name="linktoglossary")
    enquired_timestamp = Column(TIMESTAMP(timezone=True), name="enquiredtimestamp")
    key_features = Column(ARRAY(Text), name="keyfeatures")
    tags = Column(ARRAY(Text))
    virtual_tours = Column(JSONB, name="virtualtours")

    # Relationships
    misinfo = relationship(
        "ApiPropertiesDetailsV2Misinfo", back_populates="property", uselist=False
    )
    status = relationship(
        "ApiPropertiesDetailsV2Status", back_populates="property", uselist=False
    )
    stampduty = relationship(
        "ApiPropertiesDetailsV2StampDuty", back_populates="property", uselist=False
    )
    features = relationship(
        "ApiPropertiesDetailsV2Features", back_populates="property", uselist=False
    )
    branch = relationship(
        "ApiPropertiesDetailsV2Branch", back_populates="property", uselist=False
    )
    brochure = relationship(
        "ApiPropertiesDetailsV2Brochure", back_populates="property", uselist=False
    )
    price = relationship(
        "ApiPropertiesDetailsV2Price", back_populates="property", uselist=False
    )
    localtax = relationship(
        "ApiPropertiesDetailsV2LocalTax", back_populates="property", uselist=False
    )
    location = relationship(
        "ApiPropertiesDetailsV2Location", back_populates="property", uselist=False
    )
    salesinfo = relationship(
        "ApiPropertiesDetailsV2SalesInfo", back_populates="property", uselist=False
    )
    size = relationship(
        "ApiPropertiesDetailsV2Size", back_populates="property", uselist=False
    )
    mortgage = relationship(
        "ApiPropertiesDetailsV2Mortgage", back_populates="property", uselist=False
    )
    analyticsinfo = relationship(
        "ApiPropertiesDetailsV2AnalyticsInfo", back_populates="property", uselist=False
    )
    stations = relationship("ApiPropertiesDetailsV2Station", back_populates="property")
    photos = relationship("ApiPropertiesDetailsV2Photo", back_populates="property")
    epcs = relationship("ApiPropertiesDetailsV2Epc", back_populates="property")
    floorplans = relationship(
        "ApiPropertiesDetailsV2Floorplan", back_populates="property"
    )


class ApiPropertiesDetailsV2Misinfo(Base, SuperIdMixin):
    """
    Table for storing miscellaneous information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_misinfo table.
    """

    __tablename__ = "api_properties_details_v2_misinfo"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    branch_id = Column(Integer, name="branchId")
    offer_advert_stamp_type_id = Column(Text, name="offerAdvertStampTypeId")
    brand_plus = Column(Boolean, name="brandPlus")
    featured_property = Column(Boolean, name="featuredProperty")
    channel = Column(String(50))
    premium_display = Column(Boolean, name="premiumDisplay")
    premium_display_stamp_id = Column(Text, name="premiumdisplaystampid")
    country_code = Column(String(10), name="countrycode")

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="misinfo")


class ApiPropertiesDetailsV2Status(Base, SuperIdMixin):
    """
    Table for storing status information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_status table.
    """

    __tablename__ = "api_properties_details_v2_status"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    available = Column(Boolean)
    label = Column(Text)

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="status")


class ApiPropertiesDetailsV2StampDuty(Base, SuperIdMixin):
    """
    Table for storing stamp duty information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_stampduty table.
    """

    __tablename__ = "api_properties_details_v2_stampduty"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    country = Column(String(100))
    price = Column(BigInteger)
    buyer_type = Column(Text, name="buyertype")
    result = Column(Text)

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="stampduty")


class ApiPropertiesDetailsV2Features(Base, SuperIdMixin):
    """
    Table for storing features information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_features table.
    """

    __tablename__ = "api_properties_details_v2_features"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    electricity = Column(JSONB)
    broadband = Column(JSONB)
    water = Column(JSONB)
    sewerage = Column(JSONB)
    heating = Column(JSONB)
    accessibility = Column(JSONB)
    parking = Column(JSONB)
    garden = Column(JSONB)

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="features")
    risks = relationship(
        "ApiPropertiesDetailsV2FeatureRisks", back_populates="feature", uselist=False
    )
    obligations = relationship(
        "ApiPropertiesDetailsV2FeatureObligations",
        back_populates="feature",
        uselist=False,
    )


class ApiPropertiesDetailsV2Branch(Base, SuperIdMixin):
    """
    Table for storing branch information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_branch table.
    """

    __tablename__ = "api_properties_details_v2_branch"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    identifier = Column(Integer)
    name = Column(String(255))
    brand_name = Column(String(255), name="brandName")
    display_name = Column(String(255), name="displayname")
    address = Column(Text)
    logo = Column(Text)
    developer = Column(Boolean)

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="branch")


class ApiPropertiesDetailsV2Brochure(Base, SuperIdMixin):
    """
    Table for storing brochure information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_brochure table.
    """

    __tablename__ = "api_properties_details_v2_brochure"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    title = Column(String(255))
    show_brochure_lead = Column(Boolean, name="showbrochurelead")

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="brochure")
    brochure_items = relationship(
        "ApiPropertiesDetailsV2BrochureItem", back_populates="brochure"
    )


class ApiPropertiesDetailsV2BrochureItem(Base, SuperIdMixin):
    """
    Table for storing brochure items information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_brochure_items table.
    """

    __tablename__ = "api_properties_details_v2_brochure_items"

    id = Column(Integer, primary_key=True, autoincrement=True)
    brochure_api_property_id = Column(
        BigInteger,
        ForeignKey(
            "rightmove.api_properties_details_v2_brochure.api_property_id",
            ondelete="CASCADE",
        ),
        nullable=False,
    )
    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        nullable=False,
    )
    url = Column(Text)
    caption = Column(String(255))

    # Relationships
    brochure = relationship(
        "ApiPropertiesDetailsV2Brochure", back_populates="brochure_items"
    )


class ApiPropertiesDetailsV2Price(Base, SuperIdMixin):
    """
    Table for storing price information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_price table.
    """

    __tablename__ = "api_properties_details_v2_price"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    primary_price = Column(String(100), name="primaryprice")
    secondary_price = Column(String(255), name="secondaryprice")

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="price")


class ApiPropertiesDetailsV2LocalTax(Base, SuperIdMixin):
    """
    Table for storing local tax information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_localtax table.
    """

    __tablename__ = "api_properties_details_v2_localtax"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    type = Column(String(100))
    status = Column(Text)
    value = Column(String(100))

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="localtax")


class ApiPropertiesDetailsV2Location(Base, SuperIdMixin):
    """
    Table for storing location information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_location table.
    """

    __tablename__ = "api_properties_details_v2_location"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    pin_type = Column(String(100), name="pinType")
    latitude = Column(Numeric(10, 8))
    longitude = Column(Numeric(11, 8))
    map_preview_url = Column(Text, name="mapPreviewUrl")

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="location")
    streetview = relationship(
        "ApiPropertiesDetailsV2LocationStreetview",
        back_populates="location",
        uselist=False,
    )


class ApiPropertiesDetailsV2LocationStreetview(Base, SuperIdMixin):
    """
    Table for storing location streetview information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_location_streetview table.
    """

    __tablename__ = "api_properties_details_v2_location_streetview"

    location_api_property_id = Column(
        BigInteger,
        ForeignKey(
            "rightmove.api_properties_details_v2_location.api_property_id",
            ondelete="CASCADE",
        ),
        primary_key=True,
    )
    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        nullable=False,
    )
    latitude = Column(Numeric(10, 8))
    longitude = Column(Numeric(11, 8))
    heading = Column(Text)
    pitch = Column(Text)
    zoom = Column(Text)
    url = Column(Text)

    # Relationships
    location = relationship(
        "ApiPropertiesDetailsV2Location", back_populates="streetview"
    )


class ApiPropertiesDetailsV2SalesInfo(Base, SuperIdMixin):
    """
    Table for storing sales information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_salesinfo table.
    """

    __tablename__ = "api_properties_details_v2_salesinfo"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    tenure_type = Column(String(100), name="tenureType")
    tenure_display_type = Column(String(100), name="tenureDisplayType")
    ground_rent = Column(Text, name="groundRent")
    annual_service_charge = Column(Text, name="annualServiceCharge")
    estate_charge = Column(Text, name="estateCharge")
    length_of_lease = Column(Text, name="lengthOfLease")
    shared_ownership_percentage = Column(Text, name="sharedOwnershipPercentage")
    shared_ownership_rent = Column(Text, name="sharedOwnershipRent")

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="salesinfo")


class ApiPropertiesDetailsV2Size(Base, SuperIdMixin):
    """
    Table for storing size information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_size table.
    """

    __tablename__ = "api_properties_details_v2_size"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    primary_size = Column(String(100), name="primary_size")
    secondary_size = Column(Text, name="secondary_size")

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="size")


class ApiPropertiesDetailsV2Mortgage(Base, SuperIdMixin):
    """
    Table for storing mortgage information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_mortgage table.
    """

    __tablename__ = "api_properties_details_v2_mortgage"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    price = Column(BigInteger)
    property_type_alias = Column(String(100), name="propertyTypeAlias")

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="mortgage")


class ApiPropertiesDetailsV2AnalyticsInfo(Base, SuperIdMixin):
    """
    Table for storing analytics information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_analyticsinfo table.
    """

    __tablename__ = "api_properties_details_v2_analyticsinfo"

    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        primary_key=True,
    )
    branch_id = Column(String(50), name="branchId")
    property_id = Column(String(50), name="propertyId")
    online_viewing = Column(String(10), name="onlineViewing")
    image_count = Column(String(10), name="imageCount")
    floorplan_count = Column(String(10), name="floorplanCount")
    beds = Column(String(10))
    postcode = Column(String(20))
    property_type = Column(String(100), name="propertyType")
    property_sub_type = Column(String(100), name="propertySubType")
    added = Column(String(20))
    price = Column(String(50))
    tenure = Column(String(100))
    bathrooms = Column(String(10))
    shared_ownership = Column(String(10), name="sharedOwnership")
    electricity = Column(String(50))
    broadband = Column(String(50))
    water = Column(String(50))
    sewerage = Column(String(50))
    heating = Column(String(50))
    accessibility = Column(String(50))
    parking = Column(String(50))
    garden = Column(String(50))
    flood_history = Column(String(50), name="floodHistory")
    flood_defences = Column(String(50), name="floodDefences")
    flood_risk = Column(String(50), name="floodRisk")
    listed = Column(String(50))
    restrictions = Column(String(50))
    private_access = Column(String(50), name="privateAccess")
    public_access = Column(String(50), name="publicAccess")

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="analyticsinfo")


class ApiPropertiesDetailsV2Station(Base, SuperIdMixin):
    """
    Table for storing station information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_stations table.
    """

    __tablename__ = "api_properties_details_v2_stations"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        nullable=False,
    )
    station = Column(String(255))
    distance = Column(Numeric(8, 2))
    type = Column(String(50))

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="stations")


class ApiPropertiesDetailsV2Photo(Base, SuperIdMixin):
    """
    Table for storing photo information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_photos table.
    """

    __tablename__ = "api_properties_details_v2_photos"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        nullable=False,
    )
    url = Column(Text)
    thumbnail_url = Column(Text, name="thumbnailurl")
    max_size_url = Column(Text, name="maxsizeurl")
    caption = Column(Text)

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="photos")


class ApiPropertiesDetailsV2Epc(Base, SuperIdMixin):
    """
    Table for storing EPC information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_epcs table.
    """

    __tablename__ = "api_properties_details_v2_epcs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        nullable=False,
    )
    url = Column(Text)
    caption = Column(String(255))

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="epcs")


class ApiPropertiesDetailsV2Floorplan(Base, SuperIdMixin):
    """
    Table for storing floorplan information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_floorplans table.
    """

    __tablename__ = "api_properties_details_v2_floorplans"

    id = Column(Integer, primary_key=True, autoincrement=True)
    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        nullable=False,
    )
    url = Column(Text)
    thumbnail_url = Column(Text, name="thumbnailUrl")
    caption = Column(String(255))

    # Relationships
    property = relationship("ApiPropertiesDetailsV2", back_populates="floorplans")


class ApiPropertiesDetailsV2FeatureRisks(Base, SuperIdMixin):
    """
    Table for storing feature risk information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_feature_risks table.
    """

    __tablename__ = "api_properties_details_v2_feature_risks"

    feature_api_property_id = Column(
        BigInteger,
        ForeignKey(
            "rightmove.api_properties_details_v2_features.api_property_id",
            ondelete="CASCADE",
        ),
        primary_key=True,
    )
    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        nullable=False,
    )
    flood_history = Column(JSONB, name="floodhistory")
    flood_defences = Column(JSONB, name="flooddefences")
    flood_risk = Column(JSONB, name="floodrisk")

    # Relationships
    feature = relationship("ApiPropertiesDetailsV2Features", back_populates="risks")


class ApiPropertiesDetailsV2FeatureObligations(Base, SuperIdMixin):
    """
    Table for storing feature obligations information from the properties/details v2 API.
    Maps to rightmove.api_properties_details_v2_feature_obligations table.
    """

    __tablename__ = "api_properties_details_v2_feature_obligations"

    feature_api_property_id = Column(
        BigInteger,
        ForeignKey(
            "rightmove.api_properties_details_v2_features.api_property_id",
            ondelete="CASCADE",
        ),
        primary_key=True,
    )
    api_property_id = Column(
        BigInteger,
        ForeignKey("rightmove.api_properties_details_v2.id", ondelete="CASCADE"),
        nullable=False,
    )
    listed = Column(JSONB)
    restrictions = Column(JSONB)
    private_access = Column(JSONB, name="privateaccess")
    public_access = Column(JSONB, name="publicaccess")

    # Relationships
    feature = relationship(
        "ApiPropertiesDetailsV2Features", back_populates="obligations"
    )


# data_capture_rightmove_service/src/data_capture_rightmove_service/models/base.py
"""
Base model classes and common SQLAlchemy components.
"""

from sqlalchemy import Column, DateTime, MetaData, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.declarative import declared_attr
from sqlalchemy.orm import DeclarativeBase

# Define naming convention for constraints to ensure consistent naming
convention = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s",
}

# Create metadata with naming convention and schema
metadata = MetaData(naming_convention=convention, schema="rightmove")


class Base(DeclarativeBase):
    """Base class for all SQLAlchemy models."""
    
    metadata = metadata
    
    # Add created_at and updated_at timestamps to all tables
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    
    # Add tablename based on class name, using snake_case format
    @declared_attr.directive
    def __tablename__(cls) -> str:
        # Convert camel case to snake case
        import re
        name = re.sub('(?<!^)(?=[A-Z])', '_', cls.__name__).lower()
        return name


class SuperIdMixin:
    """Mixin for models that require a super_id field for tracking."""
    
    super_id = Column(UUID(as_uuid=True), nullable=False, index=True)


# data_capture_rightmove_service/src/data_capture_rightmove_service/schemas/property_data.py
"""
Schemas for property data requests and responses.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, HttpUrl, field_validator, model_validator


# Base schemas for shared fields
class PropertyBase(BaseModel):
    """Base schema for property data requests."""
    
    property_id: int = Field(..., description="Rightmove property ID")
    description: Optional[str] = Field(None, description="Optional description for tracking purposes")


# Request schemas
class FetchPropertyDetailsRequest(BaseModel):
    """Request to fetch property details from Rightmove."""
    
    property_id: Optional[int] = Field(
        None, 
        description="Rightmove property ID"
    )
    property_url: Optional[str] = Field(
        None, 
        description="Rightmove property URL (alternative to property_id)"
    )
    super_id: Optional[UUID] = Field(
        None,
        description="Optional Super ID for tracking purposes"
    )
    description: Optional[str] = Field(
        None, 
        description="Optional description for tracking purposes"
    )
    
    @model_validator(mode='after')
    def validate_property_identifier(self):
        # This validator runs after the model is created and all fields are set
        # Check that at least one of property_id or property_url is provided
        if not self.property_id and not self.property_url:
            raise ValueError("Either property_id or property_url must be provided")
        return self
        
    class Config:
        schema_extra = {
            "example": {
                "property_id": 123456789,
                "description": "Property listing for review"
            }
        }


class FetchBatchRequest(BaseModel):
    """Request to fetch a batch of properties."""
    
    property_ids: List[int] = Field(..., description="List of Rightmove property IDs to fetch")
    api_type: str = Field(..., description="API type to use: 'properties_details' or 'property_for_sale'")


# Response schemas
class FetchPropertyResponse(BaseModel):
    """Response for a property fetch operation."""
    
    property_id: int = Field(..., description="Rightmove property ID")
    super_id: UUID = Field(..., description="Tracking UUID")
    status: str = Field(..., description="Status of the fetch operation")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Timestamp of operation")
    message: Optional[str] = Field(None, description="Additional information")


class FetchBatchResponse(BaseModel):
    """Response for a batch fetch operation."""
    
    batch_id: UUID = Field(..., description="Batch operation ID")
    total: int = Field(..., description="Total number of properties in batch")
    successful: int = Field(..., description="Number of successfully fetched properties")
    failed: int = Field(..., description="Number of failed fetch operations")
    results: List[FetchPropertyResponse] = Field(..., description="Individual property fetch results")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Timestamp of operation")


# Data storage schemas
class PropertyDetailsStorageResponse(BaseModel):
    """Response when property details have been stored."""
    
    property_id: int = Field(..., description="Rightmove property ID")
    super_id: UUID = Field(..., description="Tracking UUID")
    stored: bool = Field(..., description="Whether the property was stored successfully")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Timestamp of storage")
    message: Optional[str] = Field(None, description="Additional information about storage")
    
    class Config:
        schema_extra = {
            "example": {
                "property_id": 12345678,
                "super_id": "123e4567-e89b-12d3-a456-426614174000",
                "stored": True,
                "timestamp": "2023-10-25T12:34:56.789Z",
                "message": "Property data stored successfully"
            }
        }


# Search request schemas
class PropertySearchRequest(BaseModel):
    """Request to search for properties based on criteria."""
    
    location: str = Field(..., description="Location identifier or name")
    min_price: Optional[int] = Field(None, description="Minimum price")
    max_price: Optional[int] = Field(None, description="Maximum price")
    min_bedrooms: Optional[int] = Field(None, description="Minimum number of bedrooms")
    max_bedrooms: Optional[int] = Field(None, description="Maximum number of bedrooms")
    property_type: Optional[str] = Field(None, description="Type of property")
    radius: Optional[float] = Field(None, description="Search radius in miles")
    page_number: int = Field(0, description="Page number for pagination")
    page_size: int = Field(10, description="Number of results per page")
    
    class Config:
        schema_extra = {
            "example": {
                "location": "London",
                "min_price": 200000,
                "max_price": 500000,
                "min_bedrooms": 2,
                "max_bedrooms": 3,
                "property_type": "FLAT",
                "radius": 1.0,
                "page_number": 0,
                "page_size": 10
            }
        }


# data_capture_rightmove_service/src/data_capture_rightmove_service/schemas/__init__.py
"""
Pydantic schemas for data validation, serialization, and documentation.
"""

# Core dependencies
from pydantic import BaseModel, Field
from typing import List, Optional, Union, Dict, Any
from datetime import datetime
from uuid import UUID


# data_capture_rightmove_service/src/data_capture_rightmove_service/schemas/common.py
"""
Common schemas shared across multiple endpoints.
"""

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field


class MessageResponse(BaseModel):
    """Standard message response for API operations."""
    
    message: str = Field(..., description="Response message")
    success: bool = Field(..., description="Operation success status")


class ErrorResponse(BaseModel):
    """Standard error response for API operations."""
    
    detail: str = Field(..., description="Error detail")
    error_type: Optional[str] = Field(None, description="Type of error")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Timestamp of error")


class HealthStatus(str, Enum):
    """Health status enum for health check responses."""
    
    OK = "ok"
    WARNING = "warning"
    ERROR = "error"
    DEGRADED = "degraded"


class ComponentHealth(BaseModel):
    """Health information for a single component."""
    
    status: HealthStatus = Field(..., description="Status of the component")
    message: Optional[str] = Field(None, description="Optional message about the component health")


class HealthCheckResponse(BaseModel):
    """Standard health check response."""
    
    status: HealthStatus = Field(..., description="Overall service health status")
    version: str = Field(..., description="Service version")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Timestamp of health check")
    components: Dict[str, ComponentHealth] = Field(..., description="Health of individual components")
    uptime_seconds: Optional[float] = Field(None, description="Service uptime in seconds")


# data_capture_rightmove_service/src/data_capture_rightmove_service/crud/properties_details.py
"""
CRUD operations for the properties_details endpoint data.
"""

import logging
import uuid
from typing import Dict, List, Optional, Tuple, Any

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError

from data_capture_rightmove_service.models.properties_details_v2 import (
    ApiPropertiesDetailsV2,
    ApiPropertiesDetailsV2Price,
    ApiPropertiesDetailsV2Branch,
    ApiPropertiesDetailsV2Location,
    ApiPropertiesDetailsV2LocationStreetview,
    ApiPropertiesDetailsV2Photo,
    ApiPropertiesDetailsV2Floorplan,
    ApiPropertiesDetailsV2Station,
    ApiPropertiesDetailsV2Status,
    ApiPropertiesDetailsV2Features,
    ApiPropertiesDetailsV2FeatureRisks
)

from data_capture_rightmove_service.utils.db_utils import normalize_model_instance

logger = logging.getLogger(__name__)


async def store_properties_details(db: AsyncSession, data: Dict, super_id: uuid.UUID) -> Tuple[bool, str]:
    """
    Store property details data from the properties/details API.
    
    Args:
        db: Database session
        data: Raw property details data from API
        super_id: UUID for tracking this record
        
    Returns:
        Tuple[bool, str]: Success status and message
    """
    try:
        # Log the API response structure for debugging
        logger.debug(f"API Response Top-level keys: {list(data.keys())}")
        if "status" in data:
            logger.debug(f"API Response Status: {data['status']}")
        if "message" in data:
            logger.debug(f"API Response Message: {data['message']}")
        
        # Handle both direct and nested formats for API response
        property_data = data
        
        # If the data is nested in a 'data' field (confirmed API format), extract it
        if "data" in data and isinstance(data["data"], dict):
            property_data = data["data"]
            logger.debug("Found property data nested in 'data' field")
            logger.debug(f"Nested data keys: {list(property_data.keys())}")
        
        # Extract property ID from the data
        property_id = 0
        
        # First check for identifier field which is the primary ID in the properties/details endpoint
        if "identifier" in property_data:
            property_id = int(property_data.get("identifier", 0))
            logger.debug(f"Found property ID {property_id} in 'identifier' field")
        else:
            # Try other common ID field names as fallback
            for id_field in ["propertyId", "property_id", "id"]:
                if id_field in property_data:
                    property_id = int(property_data.get(id_field, 0))
                    logger.debug(f"Found property ID {property_id} in field '{id_field}'")
                    break
                
        if property_id == 0:
            # Log the data structure to help debugging
            logger.error(f"Could not extract property ID from response. Top-level keys: {list(data.keys())}")
            if "data" in data:
                logger.error(f"Nested data keys: {list(data['data'].keys()) if isinstance(data['data'], dict) else 'not a dict'}")
            return False, "Missing or invalid property ID"
            
        # Check if property already exists to avoid duplicates
        # Create or update the API property details record
        stmt = select(ApiPropertiesDetailsV2).where(ApiPropertiesDetailsV2.id == property_id)
        result = await db.execute(stmt)
        existing_record = result.scalars().first()
        
        # Map API response to database model attributes using our normalization utility
        # This will handle mapping camelCase API fields to the correct PostgreSQL column names
        property_data_to_store = {
            **property_data,  # Include all API fields
            'id': property_id,  # Add/override specific fields
            'super_id': super_id
        }
        
        # Use our utility to normalize field names for database storage
        property_values = normalize_model_instance(ApiPropertiesDetailsV2, property_data_to_store)
        
        # Log the normalized property values for debugging and raw data for comparison
        logger.debug(f"Normalized property values: {list(property_values.keys())}")
        logger.debug(f"Raw API data keys before normalization: {list(property_data.keys())}")
        
        # Explicitly check for problematic fields and remove them from raw data
        problematic_fields = ['transactiontype', 'propertyid', 'propertysubtype']
        for field in problematic_fields:
            if field in property_values:
                logger.warning(f"Found problematic field '{field}' still present after normalization!")
            if field in property_data_to_store:
                logger.info(f"Removing problematic field '{field}' from raw data")
                property_data_to_store.pop(field, None)
        
        # Make sure transactiontype is properly handled - it needs to be stored as transaction_type in the DB
        if 'transactiontype' in property_data:
            if 'transaction_type' not in property_values:
                property_values['transaction_type'] = property_data['transactiontype']
            # Remove the problematic field to avoid errors when passing to SQLAlchemy model
            if 'transactiontype' in property_values:
                del property_values['transactiontype']
        
        # Handle other known problematic fields
        field_mappings = {
            'propertyid': 'property_id',
            'propertysubtype': 'property_sub_type'
        }
        
        for api_field, db_field in field_mappings.items():
            if api_field in property_data and db_field not in property_values:
                property_values[db_field] = property_data[api_field]
            if api_field in property_values:
                del property_values[api_field]
                
        logger.debug(f"Final property values after cleanup: {list(property_values.keys())}")
                
        if existing_record:
            logger.debug(f"Updating existing property details record for property ID {property_id}")
            # Update the existing record with our properly mapped values
            stmt = (
                update(ApiPropertiesDetailsV2)
                .where(ApiPropertiesDetailsV2.id == property_id)
                .values(**property_values)
            )
            await db.execute(stmt)
        else:
            # Create new property record - using only the normalized values
            # Log the exact keys and values we're about to use for the model
            logger.info(f"About to create ApiPropertiesDetailsV2 with these keys: {sorted(property_values.keys())}")
            
            # Explicitly remove any problematic fields that might still be present
            problematic_fields = ['transactiontype', 'propertyid', 'propertysubtype']
            for field in problematic_fields:
                if field in property_values:
                    logger.warning(f"Removing problematic field {field} just before model creation")
                    property_values.pop(field, None)
                    
            # Completely revised approach: Build a direct mapping from SQLAlchemy model definition
            # This guarantees that field names match exactly what the model expects
            
            # Extract column information directly from SQLAlchemy model with explicit awareness of 
            # the name parameter that maps Python attribute names to DB column names
            
            # Dictionary to hold information about model columns
            model_columns = {}
            
            # Map Python attribute names to their DB column names and vice versa
            python_attr_to_db_column = {}
            db_column_to_python_attr = {}
            
            # Get all columns from the SQLAlchemy model
            for column in ApiPropertiesDetailsV2.__table__.columns:
                python_attr = column.key  # Python attribute name (e.g. transaction_type)
                db_column = column.name    # DB column name (e.g. transactiontype)
                
                # Store info about each column
                model_columns[python_attr] = {
                    'type': str(column.type),
                    'db_column': db_column
                }
                
                # Create bidirectional maps between Python attributes and DB columns
                python_attr_to_db_column[python_attr] = db_column
                db_column_to_python_attr[db_column.lower()] = python_attr
                
                # Log how each column is mapped
                logger.debug(f"Model mapping: {python_attr} -> {db_column}")
                
            logger.info(f"DB column names: {sorted([c.lower() for c in db_column_to_python_attr.keys()])}")
            logger.info(f"Python attributes: {sorted(python_attr_to_db_column.keys())}")
            
            logger.info(f"Model has {len(model_columns)} columns")
            logger.info(f"Python attribute names: {sorted(python_attr_to_db_column.keys())}")
            
            # Create a clean dictionary with the correct attribute names
            clean_values = {}
            
            # 1. Start with direct attribute matches
            for attr_name in python_attr_to_db_column.keys():
                if attr_name in property_data:
                    clean_values[attr_name] = property_data[attr_name]
                    
            # Critical insight: The model is using a SQL Alchemy feature where the Python attribute name
            # (transaction_type) differs from the database column name (transactiontype).
            # We need to ensure we use the Python attribute names when instantiating the model.
            
            # Create direct field mappings from the API fields to Python attribute names
            api_field_mappings = {
                # Common lowercase API field names to Python attribute names
                'transactiontype': 'transaction_type',
                'propertyid': 'id',  # Special case: propertyid maps to id in the model
                'propertydisclaimer': 'property_disclaimer',
                'contactmethod': 'contact_method',
                'propertyphrase': 'property_phrase',
                'fulldescription': 'full_description',
                'listingupdatereason': 'listing_update_reason',
                'propertyurl': 'property_url',
                'schoolcheckerurl': 'school_checker_url',
                'lettingsinfo': 'lettings_info',
                'propertydisplaytype': 'property_display_type',
                'telephonenumber': 'telephone_number',
                'soldpricesurl': 'sold_prices_url',
                'marketinfourl': 'market_info_url',
                'linktoglossary': 'link_to_glossary',
                'enquiredtimestamp': 'enquired_timestamp',
                'keyfeatures': 'key_features',
                'virtualtours': 'virtual_tours'
            }
            
            # Map API fields to Python attribute names
            for api_field, value in property_data.items():
                api_field_lower = api_field.lower()
                
                # First try our explicit mappings
                if api_field_lower in api_field_mappings:
                    attr_name = api_field_mappings[api_field_lower]
                    logger.info(f"Mapped API field '{api_field}' to model attr '{attr_name}' via explicit mapping")
                
                # Then try the DB column mappings
                elif api_field_lower in db_column_to_python_attr:
                    attr_name = db_column_to_python_attr[api_field_lower]
                    logger.info(f"Mapped API field '{api_field}' to model attr '{attr_name}' via db column")
                
                # Fallback to direct attribute if it exists in model
                elif api_field in python_attr_to_db_column:
                    attr_name = api_field
                    logger.info(f"Using API field '{api_field}' directly as it matches a model attribute")
                
                # Skip this field if we can't map it
                else:
                    logger.warning(f"Could not map API field '{api_field}' to any model attribute")
                    continue
                
                # Skip if we've already set this attribute
                if attr_name in clean_values:
                    continue
                
                # Process special data types
                if attr_name == 'key_features':
                    # Handle array conversion
                    if value is None:
                        value = []
                    elif isinstance(value, str):
                        value = [value]
                    elif not isinstance(value, list):
                        try:
                            value = list(value)
                        except:
                            value = []
                    logger.info(f"Converted key_features to array with {len(value)} items")
                
                elif attr_name == 'virtual_tours':
                    # Handle JSON conversion
                    if not isinstance(value, dict) and value is not None:
                        try:
                            if isinstance(value, str):
                                import json
                                value = json.loads(value)
                            else:
                                value = dict(value)
                        except:
                            value = {}
                    logger.info(f"Processed virtual_tours as JSON data")
                
                # Set the attribute value in our clean values dict
                clean_values[attr_name] = value
            
            # Always ensure ID and super_id are set
            clean_values['id'] = property_id
            clean_values['super_id'] = super_id
            
            # Log what we ended up with
            logger.info(f"Final clean values have {len(clean_values)} attributes: {sorted(clean_values.keys())}")
            
            # Verify against the model's attributes
            valid_fields = set(python_attr_to_db_column.keys())
            invalid_fields = [field for field in clean_values if field not in valid_fields]
            if invalid_fields:
                logger.warning(f"Found invalid fields that will be removed: {invalid_fields}")
                for field in invalid_fields:
                    clean_values.pop(field, None)
            
            # Ensure required fields are present
            clean_values['id'] = property_id
            clean_values['super_id'] = super_id
            
            # Log the final clean values
            logger.info(f"Clean values for model creation: {sorted(clean_values.keys())}")
            
            try:
                # Create the model with only the clean values
                property_record = ApiPropertiesDetailsV2(**clean_values)
                db.add(property_record)
                await db.flush()
                logger.info(f"Successfully created property details record for ID {property_id}")
            except Exception as e:
                logger.error(f"Error creating model: {str(e)}")
                logger.error(f"Failed fields: {[k for k in clean_values.keys() if k not in valid_fields]}")
                raise

            
            # Add misinfo if present
            if misinfo_data := property_data.get("misinfo"):
                misinfo_values = normalize_model_instance(ApiPropertiesDetailsV2Misinfo, {
                    'api_property_id': property_id,
                    'super_id': super_id,
                    **misinfo_data
                })
                misinfo = ApiPropertiesDetailsV2Misinfo(**misinfo_values)
                db.add(misinfo)
                logger.debug(f"Added misinfo record for property {property_id}")
                
            # Add status if present
            if status_data := property_data.get("status"):
                status_values = normalize_model_instance(ApiPropertiesDetailsV2Status, {
                    'api_property_id': property_id,
                    'super_id': super_id,
                    **status_data
                })
                status = ApiPropertiesDetailsV2Status(**status_values)
                db.add(status)
                logger.debug(f"Added status record for property {property_id}")
                
            # Add branch if present
            if branch_data := property_data.get("branch"):
                # Debug the model structure and actual DB columns
                logger.debug("--- DEBUG: ApiPropertiesDetailsV2Branch structure and DB columns ---")
                
                # Get the actual table from SQLAlchemy metadata
                table = ApiPropertiesDetailsV2Branch.__table__
                logger.debug(f"Actual table name: {table.name}, schema: {table.schema}")
                logger.debug("Actual DB columns:")
                for column in table.columns:
                    logger.debug(f"DB Column: {column.name}, type: {column.type}, python attr: {column.key}")
                
                # Also check model attributes
                for name, attr in ApiPropertiesDetailsV2Branch.__dict__.items():
                    if hasattr(attr, 'key') and hasattr(attr, 'name'):
                        logger.debug(f"Attribute: {name}, key: {attr.key}, name: {attr.name}")
                
                # Debug the incoming branch data
                logger.debug(f"Branch data before normalization: {branch_data}")
                
                # Debug the incoming branch data
                logger.debug(f"Raw branch data: {branch_data}")
                
                # Map API fields directly to database column names (snake_case)
                # This bypasses the model definition column name overrides
                branch_db_data = {
                    'api_property_id': property_id,
                    'super_id': super_id
                }
                
                # Standard fields that don't need mapping
                for field in ['identifier', 'name', 'address', 'logo', 'developer']:
                    if field in branch_data:
                        branch_db_data[field] = branch_data[field]
                
                # Fields that need mapping from camelCase to snake_case
                if 'brandName' in branch_data:
                    branch_db_data['brand_name'] = branch_data['brandName']
                
                if 'displayName' in branch_data:
                    branch_db_data['display_name'] = branch_data['displayName']
                
                logger.debug(f"Mapped branch data for DB: {branch_db_data}")
                
                # Execute a raw SQL insert using SQLAlchemy core instead of ORM
                try:
                    # Build the insert statement with proper column names
                    stmt = f"""INSERT INTO rightmove.api_properties_details_v2_branch 
                               (api_property_id, identifier, name, brand_name, display_name, 
                                address, logo, developer, super_id) 
                               VALUES (:api_property_id, :identifier, :name, :brand_name, 
                                       :display_name, :address, :logo, :developer, :super_id)"""
                    
                    # Execute the statement directly
                    await db.execute(stmt, branch_db_data)
                    logger.debug(f"Added branch record for property {property_id} using direct SQL")
                except Exception as e:
                    logger.error(f"Error creating Branch with direct SQL: {str(e)}")
                    # Proceed without branch data
                    logger.warning("Skipping branch data due to SQL errors")
                
            # Add features if present
            if features_data := property_data.get("features"):
                # Debug the incoming features data
                logger.debug(f"Features data before normalization: {features_data}")
                
                # Manually map camelCase API fields to snake_case model attributes
                if 'floodhistory' in features_data:
                    features_data['flood_history'] = features_data.pop('floodhistory')
                    logger.debug("Manually mapped 'floodhistory' to 'flood_history'")
                
                if 'flooddefences' in features_data:
                    features_data['flood_defences'] = features_data.pop('flooddefences')
                    logger.debug("Manually mapped 'flooddefences' to 'flood_defences'")
                
                if 'floodrisk' in features_data:
                    features_data['flood_risk'] = features_data.pop('floodrisk')
                    logger.debug("Manually mapped 'floodrisk' to 'flood_risk'")
                
                features_values = normalize_model_instance(ApiPropertiesDetailsV2Features, {
                    'api_property_id': property_id,
                    'super_id': super_id,
                    **features_data
                })
                
                logger.debug(f"Features values after normalization: {features_values}")
                
                try:
                    features = ApiPropertiesDetailsV2Features(**features_values)
                    db.add(features)
                    logger.debug(f"Added features record for property {property_id}")
                except TypeError as e:
                    logger.error(f"TypeError creating Features: {str(e)}")
                    logger.error(f"Features values that caused error: {features_values}")
                    # Proceed without features data
                    logger.warning("Skipping features data due to mapping errors")
                    return True, "Stored property details with partial data"
                
                # Handle nested risk data if present
                if risks_data := features_data.get("risks"):
                    # Debug the model structure
                    logger.debug("--- DEBUG: ApiPropertiesDetailsV2FeatureRisks structure ---")
                    for name, attr in ApiPropertiesDetailsV2FeatureRisks.__dict__.items():
                        if hasattr(attr, 'key') and hasattr(attr, 'name'):
                            logger.debug(f"Attribute: {name}, key: {attr.key}, name: {attr.name}")
                    
                    # Debug the incoming risks data
                    logger.debug(f"Risks data before normalization: {risks_data}")
                    
                    # Manually map camelCase API fields to snake_case model attributes
                    if 'floodhistory' in risks_data:
                        risks_data['flood_history'] = risks_data.pop('floodhistory')
                        logger.debug("Manually mapped 'floodhistory' to 'flood_history'")
                    
                    if 'flooddefences' in risks_data:
                        risks_data['flood_defences'] = risks_data.pop('flooddefences')
                        logger.debug("Manually mapped 'flooddefences' to 'flood_defences'")
                    
                    if 'floodrisk' in risks_data:
                        risks_data['flood_risk'] = risks_data.pop('floodrisk')
                        logger.debug("Manually mapped 'floodrisk' to 'flood_risk'")
                    
                    risks_values = normalize_model_instance(ApiPropertiesDetailsV2FeatureRisks, {
                        'feature_api_property_id': property_id,
                        'api_property_id': property_id,
                        'super_id': super_id,
                        **risks_data
                    })
                    
                    logger.debug(f"Risks values after normalization: {risks_values}")
                    
                    try:
                        risks = ApiPropertiesDetailsV2FeatureRisks(**risks_values)
                        db.add(risks)
                        logger.debug(f"Added feature risks record for property {property_id}")
                    except TypeError as e:
                        logger.error(f"TypeError creating FeatureRisks: {str(e)}")
                        logger.error(f"Risks values that caused error: {risks_values}")
                        # Proceed without risks data
                        logger.warning("Skipping feature risks data due to mapping errors")
                
            # Add price if present
            if price_data := property_data.get("price"):
                # Debug the incoming price data
                logger.debug(f"Raw price data: {price_data}")
                
                # Map API fields directly to database column names (snake_case)
                # This bypasses the model definition column name overrides
                price_db_data = {
                    'api_property_id': property_id,
                    'super_id': super_id
                }
                
                # Map camelCase API fields to snake_case DB columns
                if 'primaryPrice' in price_data:
                    price_db_data['primary_price'] = price_data['primaryPrice']
                
                if 'secondaryPrice' in price_data:
                    price_db_data['secondary_price'] = price_data['secondaryPrice']
                
                logger.debug(f"Mapped price data for DB: {price_db_data}")
                
                # Execute a raw SQL insert using SQLAlchemy core instead of ORM
                try:
                    # Build the insert statement with proper column names
                    stmt = f"""INSERT INTO rightmove.api_properties_details_v2_price 
                               (api_property_id, primary_price, secondary_price, super_id) 
                               VALUES (:api_property_id, :primary_price, :secondary_price, :super_id)"""
                    
                    # Execute the statement directly
                    await db.execute(stmt, price_db_data)
                    logger.debug(f"Added price record for property {property_id} using direct SQL")
                except Exception as e:
                    logger.error(f"Error creating Price with direct SQL: {str(e)}")
                    # Continue with next record
                    logger.warning("Skipping price data due to SQL errors")
                
            # Add location if present
            if location_data := property_data.get("location"):
                # Debug the incoming location data
                logger.debug(f"Raw location data: {location_data}")
                
                # Map API fields directly to database column names (snake_case)
                # This bypasses the model definition column name overrides
                location_db_data = {
                    'api_property_id': property_id,
                    'super_id': super_id
                }
                
                # Standard fields that don't need mapping
                for field in ['latitude', 'longitude']:
                    if field in location_data:
                        location_db_data[field] = location_data[field]
                
                # Fields that need mapping from camelCase to snake_case
                if 'pinType' in location_data:
                    location_db_data['pin_type'] = location_data['pinType']
                
                if 'mapPreviewUrl' in location_data:
                    location_db_data['map_preview_url'] = location_data['mapPreviewUrl']
                
                logger.debug(f"Mapped location data for DB: {location_db_data}")
                
                # Execute a raw SQL insert using SQLAlchemy core instead of ORM
                try:
                    # Build the insert statement with proper column names
                    stmt = f"""INSERT INTO rightmove.api_properties_details_v2_location 
                               (api_property_id, pin_type, latitude, longitude, map_preview_url, super_id) 
                               VALUES (:api_property_id, :pin_type, :latitude, :longitude, :map_preview_url, :super_id)"""
                    
                    # Execute the statement directly
                    await db.execute(stmt, location_db_data)
                    logger.debug(f"Added location record for property {property_id} using direct SQL")
                    
                    # Handle nested streetview data if present
                    if streetview_data := location_data.get("streetView"):
                        # Debug the incoming streetview data
                        logger.debug(f"Raw streetview data: {streetview_data}")
                        
                        streetview_db_data = {
                            'location_api_property_id': property_id,
                            'api_property_id': property_id,
                            'super_id': super_id
                        }
                        
                        # Copy all streetview fields - they may have camelCase to snake_case issues too
                        for key, value in streetview_data.items():
                            # Convert camelCase to snake_case for keys
                            snake_key = ''.join(['_'+c.lower() if c.isupper() else c for c in key]).lstrip('_')
                            streetview_db_data[snake_key] = value
                        
                        logger.debug(f"Mapped streetview data for DB: {streetview_db_data}")
                        
                        # Execute a raw SQL insert using SQLAlchemy core instead of ORM
                        try:
                            # Build the insert statement with proper column names
                            stmt = f"""INSERT INTO rightmove.api_properties_details_v2_location_streetview 
                                       (location_api_property_id, api_property_id, url, super_id) 
                                       VALUES (:location_api_property_id, :api_property_id, :url, :super_id)"""
                            
                            # Execute the statement directly
                            await db.execute(stmt, streetview_db_data)
                            logger.debug(f"Added streetview record for property {property_id} using direct SQL")
                        except Exception as e:
                            logger.error(f"Error creating Streetview with direct SQL: {str(e)}")
                            # Proceed without streetview data
                            logger.warning("Skipping streetview data due to SQL errors")
                except Exception as e:
                    logger.error(f"Error creating Location with direct SQL: {str(e)}")
                    # Proceed without location data
                    logger.warning("Skipping location data due to SQL errors")
                    
            # Add photos if present
            if photos_data := property_data.get("photos", []):
                for photo in photos_data:
                    photo_values = normalize_model_instance(ApiPropertiesDetailsV2Photo, {
                        'api_property_id': property_id,
                        'super_id': super_id,
                        **photo
                    })
                    try:
                        photo_record = ApiPropertiesDetailsV2Photo(**photo_values)
                        db.add(photo_record)
                    except TypeError as e:
                        logger.error(f"TypeError creating Photo: {str(e)}")
                        logger.error(f"Photo values that caused error: {photo_values}")
                        # Continue with next photo
                        continue
                logger.debug(f"Added photo records for property {property_id}")
                    
            # Add floorplans if present
            if floorplans_data := property_data.get("floorplans", []):
                for floorplan in floorplans_data:
                    # Debug the incoming floorplan data
                    logger.debug(f"Raw floorplan data: {floorplan}")
                    
                    # Map API fields directly to database column names (snake_case)
                    # This bypasses the model definition column name overrides
                    floorplan_db_data = {
                        'api_property_id': property_id,
                        'super_id': super_id
                    }
                    
                    # Standard fields that don't need mapping
                    for field in ['url', 'caption']:
                        if field in floorplan:
                            floorplan_db_data[field] = floorplan[field]
                    
                    # Fields that need mapping from camelCase to snake_case
                    if 'thumbnailUrl' in floorplan:
                        floorplan_db_data['thumbnail_url'] = floorplan['thumbnailUrl']
                    
                    logger.debug(f"Mapped floorplan data for DB: {floorplan_db_data}")
                    
                    # Execute a raw SQL insert using SQLAlchemy core instead of ORM
                    try:
                        # Build the insert statement with proper column names
                        stmt = f"""INSERT INTO rightmove.api_properties_details_v2_floorplans 
                                   (api_property_id, url, thumbnail_url, caption, super_id) 
                                   VALUES (:api_property_id, :url, :thumbnail_url, :caption, :super_id)
                                   RETURNING id"""
                        
                        # Execute the statement directly
                        await db.execute(stmt, floorplan_db_data)
                    except Exception as e:
                        logger.error(f"Error creating Floorplan with direct SQL: {str(e)}")
                        # Continue with next floorplan
                        continue
                logger.debug(f"Added floorplan records for property {property_id} using direct SQL")
        
        # Add nearest stations if present
        if stations_data := property_data.get("nearestStations", []):
            for station in stations_data:
                station_values = normalize_model_instance(ApiPropertiesDetailsV2Station, {
                    'api_property_id': property_id,
                    'super_id': super_id,
                    **station
                })
                ns = ApiPropertiesDetailsV2Station(**station_values)
                db.add(ns)
            logger.debug(f"Added {len(stations_data)} station records for property {property_id}")
        
        await db.commit()
        logger.info(f"Successfully stored property {property_id} details")
        return True, f"Successfully stored property {property_id} details"
        
    except IntegrityError as e:
        await db.rollback()
        logger.error(f"Database integrity error when storing property details: {str(e)}")
        return False, f"Database integrity error: {str(e)}"
        
    except Exception as e:
        await db.rollback()
        logger.error(f"Error storing property details: {str(e)}")
        return False, f"Error storing property details: {str(e)}"


async def get_property_details_by_id(db: AsyncSession, property_id: int) -> Optional[Dict[str, Any]]:
    """
    Get property details by ID with all related information.
    
    Args:
        db: Database session
        property_id: Rightmove property ID
        
    Returns:
        Optional[Dict[str, Any]]: Property details or None if not found
    """
    try:
        # Query the main property details
        result = await db.execute(select(ApiPropertiesDetailsV2).where(ApiPropertiesDetailsV2.id == property_id))
        property_details = result.scalar_one_or_none()
        
        if not property_details:
            return None
            
        # Get branch information
        branch_result = await db.execute(
            select(ApiPropertiesDetailsV2Branch).where(ApiPropertiesDetailsV2Branch.api_property_id == property_id)
        )
        branch = branch_result.scalar_one_or_none()
        
        # Get price information
        price_result = await db.execute(
            select(ApiPropertiesDetailsV2Price).where(ApiPropertiesDetailsV2Price.api_property_id == property_id)
        )
        price = price_result.scalar_one_or_none()
        
        # Get location information
        location_result = await db.execute(
            select(ApiPropertiesDetailsV2Location).where(ApiPropertiesDetailsV2Location.api_property_id == property_id)
        )
        location = location_result.scalar_one_or_none()
        
        # Get images
        images_result = await db.execute(
            select(ApiPropertiesDetailsV2Photo)
            .where(ApiPropertiesDetailsV2Photo.api_property_id == property_id)
        )
        images = images_result.scalars().all()
        
        # Get floorplans
        floorplans_result = await db.execute(
            select(ApiPropertiesDetailsV2Floorplan)
            .where(ApiPropertiesDetailsV2Floorplan.api_property_id == property_id)
        )
        floorplans = floorplans_result.scalars().all()
        
        # Get nearest stations
        stations_result = await db.execute(
            select(ApiPropertiesDetailsV2Station)
            .where(ApiPropertiesDetailsV2Station.api_property_id == property_id)
        )
        stations = stations_result.scalars().all()
        
        # Convert database models to dictionary
        property_dict = {
            "id": property_details.id,
            "super_id": str(property_details.super_id),
            "transaction_type": property_details.transaction_type,
            "channel": property_details.channel,
            "bedrooms": property_details.bedrooms,
            "bathrooms": property_details.bathrooms,
            "address": property_details.address,
            "contact_method": property_details.contact_method,
            "property_disclaimer": property_details.property_disclaimer,
            "property_phrase": property_details.property_phrase,
            "full_description": property_details.full_description,
            "listing_update_reason": property_details.listing_update_reason,
            "property_url": property_details.property_url,
            "school_checker_url": property_details.school_checker_url,
            "lettings_info": property_details.lettings_info,
            "property_display_type": property_details.property_display_type,
            "telephone_number": property_details.telephone_number,
            "saved": property_details.saved,
            "sold_prices_url": property_details.sold_prices_url,
            "market_info_url": property_details.market_info_url,
            "note": property_details.note,
            "link_to_glossary": property_details.link_to_glossary,
            "enquired_timestamp": property_details.enquired_timestamp,
            "key_features": property_details.key_features,
            "tags": property_details.tags,
            "virtual_tours": property_details.virtual_tours,
            "branch": branch.__dict__ if branch else None,
            "price": price.__dict__ if price else None,
            "location": location.__dict__ if location else None,
            "images": [img.__dict__ for img in images] if images else [],
            "floorplans": [fp.__dict__ for fp in floorplans] if floorplans else [],
            "nearest_stations": [ns.__dict__ for ns in stations] if stations else [],
            "created_at": property_details.created_at.isoformat(),
            "updated_at": property_details.updated_at.isoformat(),
        }
        
        # Clean up the dictionaries to remove SQLAlchemy instance state
        for dict_key in ["branch", "price", "location"]:
            if property_dict[dict_key]:
                property_dict[dict_key].pop("_sa_instance_state", None)
                
        for items_key in ["images", "floorplans", "nearest_stations"]:
            for item in property_dict[items_key]:
                item.pop("_sa_instance_state", None)
                
        return property_dict
        
    except Exception as e:
        logger.error(f"Error retrieving property details: {str(e)}")
        return None


async def get_all_property_ids(db: AsyncSession, limit: int = 1000, offset: int = 0) -> List[int]:
    """
    Get all property IDs stored in the database.
    
    Args:
        db: Database session
        limit: Maximum number of IDs to return
        offset: Offset for pagination
        
    Returns:
        List[int]: List of property IDs
    """
    try:
        result = await db.execute(
            select(ApiPropertiesDetailsV2.id)
            .order_by(ApiPropertiesDetailsV2.id)
            .limit(limit)
            .offset(offset)
        )
        return [row[0] for row in result.fetchall()]
    except Exception as e:
        logger.error(f"Error retrieving all property IDs: {str(e)}")
        return []


# data_capture_rightmove_service/src/data_capture_rightmove_service/crud/__init__.py
"""
CRUD operations for database interactions in the Data Capture Rightmove Service.
"""

from data_capture_rightmove_service.crud.properties_details import (
    store_properties_details,
    get_property_details_by_id,
    get_all_property_ids
)
from data_capture_rightmove_service.crud.property_details import (
    store_property_details,
    get_property_sale_details_by_id,
    get_all_property_sale_ids
)

__all__ = [
    'store_properties_details',
    'get_property_details_by_id',
    'get_all_property_ids',
    'store_property_details',
    'get_property_sale_details_by_id',
    'get_all_property_sale_ids'
]


# data_capture_rightmove_service/src/data_capture_rightmove_service/crud/property_details.py
"""
CRUD operations for the property-for-sale/detail endpoint data.
"""

import logging
import uuid
from typing import Dict, List, Optional, Tuple, Any

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError

from data_capture_rightmove_service.models.property_details import (
    ApiPropertyDetails,
    ApiPropertyDetailPrice,
    ApiPropertyDetailCustomer,
    ApiPropertyDetailImage,
    ApiPropertyDetailFloorplan
)

from data_capture_rightmove_service.utils.property_mapper import map_property_data
from data_capture_rightmove_service.utils.db_utils import normalize_model_instance

logger = logging.getLogger(__name__)


async def store_property_details(db: AsyncSession, data: Dict, super_id: uuid.UUID) -> Tuple[bool, str]:
    """
    Store property details data from the buy/property-for-sale/detail API.
    
    Args:
        db: Database session
        data: Raw property details data from API
        super_id: UUID for tracking this record
        
    Returns:
        Tuple[bool, str]: Success status and message
    """
    try:
        # Extract property ID from the data - handle both direct and nested formats
        property_id = 0
        property_data = data
        
        # Check if the data is nested in 'data' field
        if "data" in data and isinstance(data["data"], dict):
            property_data = data["data"]
            logger.debug(f"Found property data nested in 'data' field")

        # Try to find the property ID in common field names
        for id_field in ["id", "propertyId", "property_id"]:
            if id_field in property_data:
                property_id = int(property_data[id_field])
                logger.debug(f"Found property ID {property_id} in field '{id_field}'")
                break
        
        # Log the API response structure for debugging
        logger.debug(f"API Response Top-level keys: {list(data.keys())}")
        if "data" in data and isinstance(data["data"], dict):
            logger.debug(f"API Response Nested data keys: {list(data['data'].keys())}")
            
        if property_id == 0:
            # Log the data structure to help debugging
            logger.error(f"Could not extract property ID from response. Top-level keys: {list(data.keys())}")
            if "data" in data:
                logger.error(f"Nested data keys: {list(data['data'].keys()) if isinstance(data['data'], dict) else 'not a dict'}")
            return False, "Missing or invalid property ID"
            
        # Check if property already exists to avoid duplicates
        result = await db.execute(select(ApiPropertyDetails).where(ApiPropertyDetails.property_id == property_id))
        existing_property = result.scalar_one_or_none()
        
        if existing_property:
            logger.info(f"Property {property_id} already exists in database")
            return True, f"Property {property_id} already exists"
        
        # Map API response to database model attributes using our normalization utility
        # This will handle mapping camelCase API fields to the correct PostgreSQL column names
        property_data_to_store = {
            **property_data,  # Include all API fields
            'property_id': property_id,  # Add/override specific fields
            'super_id': super_id
        }
        
        # Use our utility to normalize field names for database storage
        # This will filter out relationships and only keep actual column attributes
        property_values = normalize_model_instance(ApiPropertyDetails, property_data_to_store)
        
        # Log the normalized property values for debugging
        logger.debug(f"Normalized property values: {list(property_values.keys())}")
        
        # Extract nested relationship objects using the original API keys (camelCase format)
        # These will be handled separately after creating the main record
        price_data = property_data.get("price")
        customer_data = property_data.get("customer")
        images_data = property_data.get("images", [])
        floorplans_data = property_data.get("floorplans", [])
        
        # Create main property record
        property_record = ApiPropertyDetails(**property_values)
        
        # Add the record to the database
        db.add(property_record)
        await db.flush()
        
        db_id = property_record.id
        logger.debug(f"Created main property record with ID {db_id}")
        
        # Add price information if present
        if price_data:
            # Use normalize_model_instance for consistent field mapping
            price_values = normalize_model_instance(
                ApiPropertyDetailPrice,
                {"api_property_detail_id": db_id, **price_data}
            )
            price_record = ApiPropertyDetailPrice(**price_values)
            db.add(price_record)
            logger.debug(f"Added price record for property {db_id}")
        
        # Add customer information if present
        if customer_data:
            customer_values = normalize_model_instance(
                ApiPropertyDetailCustomer,
                {"api_property_detail_id": db_id, **customer_data}
            )
            customer_record = ApiPropertyDetailCustomer(**customer_values)
            db.add(customer_record)
            logger.debug(f"Added customer record for property {db_id}")
        
        # Add images if present
        if images_data:
            for idx, image_data in enumerate(images_data):
                image_values = normalize_model_instance(
                    ApiPropertyDetailImage,
                    {
                        "api_property_detail_id": db_id,
                        "order_index": idx,
                        **image_data
                    }
                )
                image_record = ApiPropertyDetailImage(**image_values)
                db.add(image_record)
            logger.debug(f"Added {len(images_data)} image records for property {db_id}")
        
        # Add floorplans if present
        if floorplans_data:
            for idx, floorplan_data in enumerate(floorplans_data):
                floorplan_values = normalize_model_instance(
                    ApiPropertyDetailFloorplan,
                    {
                        "api_property_detail_id": db_id,
                        "order_index": idx,
                        **floorplan_data
                    }
                )
                floorplan_record = ApiPropertyDetailFloorplan(**floorplan_values)
                db.add(floorplan_record)
            logger.debug(f"Added {len(floorplans_data)} floorplan records for property {db_id}")
        
        await db.commit()
        logger.info(f"Successfully stored property {property_id} details")
        return True, f"Successfully stored property {property_id} details"
        
    except IntegrityError as e:
        await db.rollback()
        logger.error(f"Database integrity error when storing property details: {str(e)}")
        return False, f"Database integrity error: {str(e)}"
        
    except Exception as e:
        await db.rollback()
        logger.error(f"Error storing property details: {str(e)}")
        return False, f"Error storing property details: {str(e)}"


async def get_property_sale_details_by_id(db: AsyncSession, property_id: int) -> Optional[Dict[str, Any]]:
    """
    Get property sale details by ID with all related information.
    
    Args:
        db: Database session
        property_id: Rightmove property ID
        
    Returns:
        Optional[Dict[str, Any]]: Property details or None if not found
    """
    try:
        # Query the main property details
        result = await db.execute(select(ApiPropertyDetails).where(ApiPropertyDetails.property_id == property_id))
        property_details = result.scalar_one_or_none()
        
        if not property_details:
            return None
            
        db_id = property_details.id
            
        # Get the price information
        price_result = await db.execute(
            select(ApiPropertyDetailPrice).where(ApiPropertyDetailPrice.api_property_detail_id == db_id)
        )
        price = price_result.scalar_one_or_none()
        
        # Get the customer information
        customer_result = await db.execute(
            select(ApiPropertyDetailCustomer).where(ApiPropertyDetailCustomer.api_property_detail_id == db_id)
        )
        customer = customer_result.scalar_one_or_none()
        
        # Get images
        images_result = await db.execute(
            select(ApiPropertyDetailImage)
            .where(ApiPropertyDetailImage.api_property_detail_id == db_id)
        )
        images = images_result.scalars().all()
        
        # Get floorplans
        floorplans_result = await db.execute(
            select(ApiPropertyDetailFloorplan)
            .where(ApiPropertyDetailFloorplan.api_property_detail_id == db_id)
        )
        floorplans = floorplans_result.scalars().all()
        
        # Convert database models to dictionary
        property_dict = {
            "id": property_details.id,
            "property_id": property_details.property_id,
            "super_id": str(property_details.super_id),
            "property_type": property_details.property_type,
            "bedrooms": property_details.bedrooms,
            "bathrooms": property_details.bathrooms,
            "summary": property_details.summary,
            "display_address": property_details.display_address,
            "country_code": property_details.country_code,
            "location_title": property_details.location_title,
            "latitude": property_details.latitude,
            "longitude": property_details.longitude,
            "listing_date": property_details.listing_date.isoformat() if property_details.listing_date else None,
            "property_subtype": property_details.property_subtype,
            "for_auction": property_details.for_auction,
            "tenure": property_details.tenure,
            "deal_type": property_details.deal_type,
            "development": property_details.development,
            "commercial": property_details.commercial,
            "telephone": property_details.telephone,
            "property_url": property_details.property_url,
            "customer_type": property_details.customer_type,
            "description": property_details.description,
            "outcode": property_details.outcode,
            "image_count": property_details.image_count,
            "features": property_details.features,
            "price": price.__dict__ if price else None,
            "customer": customer.__dict__ if customer else None,
            "images": [img.__dict__ for img in images] if images else [],
            "floorplans": [fp.__dict__ for fp in floorplans] if floorplans else [],
            "created_at": property_details.created_at.isoformat(),
            "updated_at": property_details.updated_at.isoformat(),
        }
        
        # Clean up the dictionaries to remove SQLAlchemy instance state
        for dict_key in ["price", "customer"]:
            if property_dict[dict_key]:
                property_dict[dict_key].pop("_sa_instance_state", None)
                
        for items_key in ["images", "floorplans"]:
            for item in property_dict[items_key]:
                item.pop("_sa_instance_state", None)
                
        return property_dict
        
    except Exception as e:
        logger.error(f"Error retrieving property sale details: {str(e)}")
        return None


async def get_all_property_sale_ids(db: AsyncSession, limit: int = 1000, offset: int = 0) -> List[int]:
    """
    Get all property sale IDs stored in the database.
    
    Args:
        db: Database session
        limit: Maximum number of IDs to return
        offset: Offset for pagination
        
    Returns:
        List[int]: List of property IDs
    """
    try:
        result = await db.execute(
            select(ApiPropertyDetails.property_id)
            .order_by(ApiPropertyDetails.property_id)
            .limit(limit)
            .offset(offset)
        )
        return [row[0] for row in result.fetchall()]
    except Exception as e:
        logger.error(f"Error retrieving all property sale IDs: {str(e)}")
        return []


