name: Deploy to Production Server with Docker Compose

on:
  push:
    branches:
      - staging # Trigger on push to the staging branch
  workflow_dispatch:

env:
  DOCKER_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  # Define image names here for consistency
  AUTH_SERVICE_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/auth_service
  SUPER_ID_SERVICE_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/super_id_service
  DATA_CAPTURE_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/data_capture_rightmove_service

jobs:
  #########################################
  # Job 1: Detect Which Services Changed #
  #########################################
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      auth_service: ${{ steps.filter.outputs.auth_service }}
      super_id_service: ${{ steps.filter.outputs.super_id_service }}
      data_capture_rightmove_service: ${{ steps.filter.outputs.data_capture_rightmove_service }}
      # We need to force a build if the workflow itself changes
      workflow_changed: ${{ steps.filter.outputs.workflow_changed }}
    steps:
      - uses: actions/checkout@v3
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            auth_service:
              - 'auth_service/**'
            super_id_service:
              - 'super_id_service/**'
            data_capture_rightmove_service:
              - 'data_capture_rightmove_service/**'
            workflow_changed:
              - '.github/workflows/**'

  ##############################################
  # Job 2: Build and Push Images for Services #
  ##############################################
  build-and-push:
    needs: detect-changes
    # UPDATE: Force build if workflow changes, OR if any service changes
    if: needs.detect-changes.outputs.workflow_changed == 'true' || needs.detect-changes.outputs.auth_service == 'true' || needs.detect-changes.outputs.super_id_service == 'true' || needs.detect-changes.outputs.data_capture_rightmove_service == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # Define each service that can be built
        service:
          - name: auth_service
            path: ./auth_service
          - name: super_id_service
            path: ./super_id_service
          - name: data_capture_rightmove_service
            path: ./data_capture_rightmove_service
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up QEMU for multi-arch builds
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_MONOREPO_TOKEN }}

      - name: Build and Push Docker Image for ${{ matrix.service.name }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.path }}
          file: ${{ matrix.service.path }}/Dockerfile.prod
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ env.DOCKER_USERNAME }}/${{ matrix.service.name }}:latest

  ####################################
  # Job 3: Deploy to Staging Server #
  ####################################
  deploy:
    # UPDATE: Now runs even if build is skipped, but checks if it ran
    needs: [build-and-push, detect-changes]
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e

            mkdir -p /home/ubuntu/paservices
            cd /home/ubuntu/paservices

            echo "Pulling latest code from origin/staging..."
            git checkout staging
            git pull origin staging

            echo "Exporting secrets to environment..."
            export DOCKER_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
            export ACME_EMAIL=${{ secrets.ACME_EMAIL }}
            export AUTH_SERVICE_DOMAIN=${{ secrets.AUTH_SERVICE_DOMAIN }}
            export SUPER_ID_SERVICE_DOMAIN=${{ secrets.SUPER_ID_SERVICE_DOMAIN }}
            export DATA_CAPTURE_RIGHTMOVE_SERVICE_DOMAIN=${{ secrets.DATA_CAPTURE_RIGHTMOVE_SERVICE_DOMAIN }}
            export SUPABASE_URL=${{ secrets.SUPABASE_URL }}
            export SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
            export SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
            export AUTH_SERVICE_DATABASE_URL=${{ secrets.AUTH_SERVICE_DATABASE_URL }}
            export SUPER_ID_SERVICE_DATABASE_URL=${{ secrets.SUPER_ID_SERVICE_DATABASE_URL }}
            export DATA_CAPTURE_RIGHTMOVE_SERVICE_DATABASE_URL=${{ secrets.DATA_CAPTURE_RIGHTMOVE_SERVICE_DATABASE_URL }}
            export M2M_JWT_SECRET_KEY=${{ secrets.M2M_JWT_SECRET_KEY }}
            export DATA_CAPTURE_M2M_CLIENT_ID=${{ secrets.DATA_CAPTURE_M2M_CLIENT_ID }}
            export DATA_CAPTURE_M2M_CLIENT_SECRET=${{ secrets.DATA_CAPTURE_M2M_CLIENT_SECRET }}
            export RAPID_API_KEY=${{ secrets.RAPID_API_KEY }}

            echo "Logging into Docker Hub..."
            echo ${{ secrets.DOCKERHUB_MONOREPO_TOKEN }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

            echo "Pulling latest Docker images..."
            docker compose -f docker-compose.prod.yml pull

            echo "Running database migrations..."
            docker compose -f docker-compose.prod.yml run --rm auth_service alembic upgrade head
            docker compose -f docker-compose.prod.yml run --rm super_id_service alembic upgrade head

            echo "Starting application stack..."
            docker compose -f docker-compose.prod.yml up -d --remove-orphans

            echo "Cleaning up old Docker images..."
            docker image prune -f
